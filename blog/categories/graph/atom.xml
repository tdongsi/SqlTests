<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Graph | Personal Interview Notes]]></title>
  <link href="http://tdongsi.github.io/SqlTests/blog/categories/graph/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/SqlTests/"/>
  <updated>2021-10-23T18:54:42-07:00</updated>
  <id>http://tdongsi.github.io/SqlTests/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Graph Data Structures]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2015/05/02/graph-data-structures/"/>
    <updated>2015-05-02T10:54:59-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2015/05/02/graph-data-structures</id>
    <content type="html"><![CDATA[<p>Summary of chapter 14 &ldquo;Graph Algorithms&rdquo; in &ldquo;Data Structures &amp; Algorithms in Python&rdquo; by GTG.</p>

<!--more-->


<h3>Vertices and Edges</h3>

<pre><code class="python Vertex">class Vertex:
    """Lightweight vertex structure for graph"""
    __slots__ = "_element"

    def __init__(self, x):
        self._element = x

    def element(self):
        return self._element

    def __hash__(self):
        return hash(id(self))

    def __str__(self):
        return "[Vertex: %s]" % self._element
</code></pre>

<pre><code class="python Edge">class Edge:
    """Lightweight edge structure for graph"""
    __slots__ = "_src", "_des", "_element"

    def __init__(self, u, v, x):
        self._src = u  # source
        self._des = v  # destination
        self._element = x

    def endpoints(self):
        return self._src, self._des

    def opposite(self, u):
        if u is self._src:
            return self._des
        elif u is self._des:
            return self._src
        else:
            raise ValueError("Unknown vertex")

    def element(self):
        return self._element

    def set_element(self, val):
        self._element = val
        pass

    def __hash__(self):
        return hash((self._src, self._des))

    def __str__(self):
        return "%s &gt;- %s -&gt; %s" % (self._src, self._element, self._des)
</code></pre>

<h3>Graph</h3>

<pre><code class="python Graph">class Graph:
    """Simple graph using an adjancency map"""

    def __init__(self, directed=False):
        self._outgoing = {}
        # Only create the second map for directed graph
        self._incoming = {} if directed else self._outgoing

    def is_directed(self):
        return self._outgoing is not self._incoming

    def vertex_count(self):
        """Return the number of vertices in the graph"""
        return len(self._outgoing)

    def vertices(self):
        """Return the iteration of all vertices"""
        return self._outgoing.keys()

    def edge_count(self):
        """Return the number of edges"""
        total = sum([len(self._outgoing[v]) for v in self.vertices()])
        return total if self.is_directed() else total//2

    def edges(self):
        """Return the iteration of all edges"""
        result = set()
        for secondary_map in self._outgoing.values():
            result.update(secondary_map.values())
        return result

    def get_edge(self, u, v):
        # TRICKY: self._outgoing[u][v] will raise KeyError instead of None if (u,v) not found
        return self._outgoing[u].get(v)

    def degree(self, v, outgoing=True):
        if outgoing:
            return len(self._outgoing[v])
        else:
            return len(self._incoming[v])

    def incident_edges(self, v, outgoing=True):
        """Return an *iteration* of incident edges"""
        adj = self._outgoing if outgoing else self._incoming
        for e in adj[v].values():
            yield e

    def insert_vertex(self, x=None):
        v = Vertex(x)
        self._outgoing[v] = {}
        if self.is_directed():
            self._incoming[v] = {}
        return v

    def insert_edge(self, u, v, x=None):
        e = Edge(u, v, x)
        self._outgoing[u][v] = e
        self._incoming[v][u] = e
        return e

    def delete_edge(self, u, v):
        del self._outgoing[u][v]
        del self._incoming[v][u]
        pass
</code></pre>

<h3>Modifications for Network Flows</h3>

<p>Note that for Network Flow problem, we must add <code>set_element</code> to Edge class and <code>delete_edge</code> to Graph class.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graph Data Algorithms]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2015/05/01/graph-algorithms/"/>
    <updated>2015-05-01T03:12:53-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2015/05/01/graph-algorithms</id>
    <content type="html"><![CDATA[<p>Summary of chapter 14 &ldquo;Graph Algorithms&rdquo; in &ldquo;Data Structures &amp; Algorithms in Python&rdquo; by GTG.</p>

<!--more-->


<h3>Graph traversals</h3>

<h4>DFS</h4>

<pre><code class="python Stack version">def DFS_iter(g: Graph, s: Vertex) -&gt; dict:
    """DFS traversal using a stack."""
    to_visit = [s]
    discovered = {s: None}

    while to_visit:
        u = to_visit.pop()

        for e in g.incident_edges(u):
            v = e.opposite(u)
            if v not in discovered:
                discovered[v] = e
                to_visit.append(v)

    return discovered
</code></pre>

<p>The book version (shown below) is using recusion (still practical since it&rsquo;s tail-recursion) but some interviewers may not like it.</p>

<pre><code class="python Book version">def DFS(g:Graph, u:Vertex, discovered):
    """ DFS traversal of the undiscovered portion of Graph g starting at Vertex u.
    Example: start DFS traversal with DFS(g, u, {u: None}).

    :param g: given Graph
    :param u: starting Vertex
    :param discovered: Mapping each vertex to the edge used to discover it.
    :return:
    """
    for e in g.incident_edges(u):
        v = e.opposite(u)
        if v not in discovered:
            discovered[v] = e
            DFS(g, v, discovered)

    pass
</code></pre>

<h4>BFS</h4>

<pre><code class="python Queue version">def BFS(g: Graph, s: Vertex) -&gt; dict:
    from collections import deque

    to_visit = deque([s])
    discovered = {s: None}

    while to_visit:
        u = to_visit.popleft()

        for e in g.incident_edges(u):
            v = e.opposite(u)

            if v not in discovered:
                discovered[v] = e
                to_visit.append(v)

    return discovered
</code></pre>

<p>The queue version is very similar to DFS (stack version).
The book version (shown below) is iterative but looks much more clumsy, due to constructing a queue (<code>level</code>, <code>next_level</code>) without using <code>deque</code>.</p>

<pre><code class="python Book version">def BFS(g:Graph, s:Vertex, discovered):
    """ BFS traversal of the undiscovered portion of Graph g starting at vertex s.

    :param g: give Graph
    :param s: starting Vertex
    :param discovered: Mapping each vertex to the edge used to discover it.
    :return:
    """
    level = [s]

    while len(level) &gt; 0:
        next_level = []
        for v in level:
            for e in g.incident_edges(v):
                u = e.opposite(v)
                if u not in discovered:
                    discovered[u] = e
                    next_level.append(u)

        level = next_level
</code></pre>

<h4>Others</h4>

<p>Path construction after traversal (either DFS or BFS).</p>

<pre><code class="python Construct path">def construct_path(u:Vertex, v:Vertex, discovered):
    """ Construct a path from u to v."""
    path = []

    if v in discovered:
        path.append(v)

        walk = v
        while walk is not u:
            e = discovered[walk]
            parent = e.opposite(walk)
            path.append(parent)
            walk = parent

        path.reverse()

    return path
</code></pre>

<h3>Transitive Closure</h3>

<p>Background: If the graph representation is adjacency list or adjacency map, we can answer the question of reachability for any u and v in <code>O(n+m)</code> (where <code>n</code> is the number of nodes, <code>m</code> is the number of edges).
However, if you have to answer <strong>many</strong> reachability queries (e.g., navigation application), it is better to construct a transitive closure for that graph.</p>

<p>A transitive closure <code>G'</code> is for a directed graph <code>G</code>: any u and v that are reachable, there is an edge (u, v) in <code>Gâ€™</code>.</p>

<p>In the classic adjacency list or adjacency map representation, transitive closure can be constructed in <code>O(n(n+m))</code> by repeating DFS at each vertex.
However, when the graph is dense (m -> n<sup>2</sup>), you is better off with Floyd-Warshall algorithm <code>O(n^3)</code> using <strong>adjacency matrix</strong> representation.
Floyd-Warshall requires get_edge and insert_edge to be done in <code>O(1)</code> time, which necessitates adjacency matrix requirements.</p>

<p>In theory, <code>O(n^3)</code> is not better than repeated DFS traversals <code>O(n(n+m))</code>.
However, in practice, Floyd-Warshall is faster and easier to implement because there are fewer low-level operations.
However, when the graph is sparse, repeated DFS traversal approach is better in time and space complexity.</p>

<pre><code class="python Floyd-Warshall implementation">def floyd_warshall(g:Graph) -&gt; Graph:
    """ Return a new graph that is the transite closure of g.

    :param g: input graph
    :return: the transitive closure of g.
    """
    closure = deepcopy(g)
    verts = list(closure.vertices())
    n = len(verts)

    for k in range(n):
        for i in range(n):
            # verify that edge(i, k) exists in the partial closure
            if i != k and closure.get_edge(verts[i], verts[k]) is not None:
                for j in range(n):
                    # verify that edge(k, j) exists in the partial closure
                    if i != j != k and closure.get_edge(verts[k], verts[j]) is not None:
                        if closure.get_edge(verts[i], verts[j]) is None:
                            # if (i, j) not yet included, add it to the closure
                            closure.insert_edge(verts[i], verts[j])

    return closure
</code></pre>

<h3>DAG and topological sorting.</h3>

<pre><code class="python Topological sorting">def topological_sort(g: Graph) -&gt; list:
    """ Return a list of vertices of DAG in topological order

    :param g: a directed acyclic graph (DAG)
    :return: list of topological sort
    """
    topo = []
    ready = []
    incount = {}

    for u in g.vertices():
        incount[u] = g.degree(u, False)  # incoming count/degree
        if incount[u] == 0:
            # u is free of constraints
            ready.append(u)

    while len(ready) &gt; 0:
        u = ready.pop()
        topo.append(u)

        for e in g.incident_edges(u):
            v = e.opposite(u)
            incount[v] -= 1
            if incount[v] == 0:
                ready.append(v)

    return topo
</code></pre>

<p>A directed graph may have more than one topological ordering.</p>

<blockquote><p><strong>Proposition 14.21</strong>: A directed graph has a topological sorting if and only if it is acyclic.</p>

<p><strong>Proposition 14.22</strong>: Let G be the directed graph with n vertices and m edges, using an adjacency list representation. The topological sorting algorithm runs in O(n+m) time using O(n) auxiliary space, and either computes a topological ordering of G or fails to include some vertices, which indicates that G has a directed cycle.</p></blockquote>

<p>Summary of propositions:</p>

<ul>
<li>Time complexity O(n+m). Space complexity O(n)</li>
<li>The vertices NOT included &ldquo;topo&rdquo; must contain a directed cycle.</li>
</ul>


<h3>Shortest Paths</h3>

<p>We have a few choices for implementing &ldquo;adaptable priority queue with location-aware entries&rdquo; (at least <code>remove_min</code> required) in Dijkstra&rsquo;s algorithm:</p>

<ul>
<li>Unsorted sequence implementation -> <code>O(n^2 +m)</code> runtime.</li>
<li>A heap implementation -> <code>O( (n+m)log(n) )</code> runtime.</li>
<li>Fibonacci heap implementation -> <code>O(m +nlog(n))</code> runtime.</li>
</ul>


<p>The &ldquo;heap implementation&rdquo; is &ldquo;AdaptableHeapPriorityQueue&rdquo; class from the chapter 9 of the same textbook.
The &ldquo;Unsorted sequence implementation&rdquo; is implemented as follows, using the same signature of the above class for later compatibility:</p>

<pre><code class="python Simple Adaptable Priority Queue implementation">class AdaptableUnsortedPriorityQueue():
    """ Mocking AdaptableHeapPriorityQueue.
    loc =&gt; key in internal map
    key, val =&gt; value in internal map
    """

    def __init__(self):
        self._map = {}

    def add(self, key, value):
        """Add a key-value pair."""
        self._map[value] = (key, value)
        return value

    def update(self, loc, newkey, newval):
        """Update the key and value for the entry"""
        self._map[loc] = (newkey, newval)

    def is_empty(self):
        return (len(self._map) == 0)

    def remove_min(self):

        min_key = float('inf')
        min_loc = None
        min_return = None

        for loc, val in self._map.items():
            if val[0] &lt; min_key:
                min_key = val[0]
                min_loc = loc
                min_return = val

        del self._map[min_loc]
        return min_return
</code></pre>

<p>Python implementation of Dijkstra&rsquo;s algorithm is shown below.
Dijkstra&rsquo;s algorithm is analogous to a weighted BFS traversal.
A few assumptions must be true in this implementation:</p>

<ul>
<li>Theoretical requirement: All the weights are nonnegative.</li>
<li><code>e.element()</code> returns the weight of the edge.</li>
</ul>


<pre><code class="python Dijkstra's algorithm">def shortest_path_lengths(g:Graph, s:Vertex):
    """ Compute shortest-path distances from src to reachable vertices of g.
    Dijkstra's Algorithm for finding shortest paths.

    :param g: directed or undirected Graph. e.element() must return non-negative weight
    :param s: Starting vertex
    :return: dictionary mapping each reachable vertex to its distance from s.
    """

    d = {}      # d[v] is upper bound from s to v
    cloud = {}  # map reachable v to its d[v] value
    pq = AdaptableUnsortedPriorityQueue()   # vertex v will have key d[v]
    pqlocator = {}      # map from vertex to its pq locator

    for v in g.vertices():
        if v is s:
            d[v] = 0
        else:
            d[v] = float('inf')

        pqlocator[v] = pq.add(d[v], v)

    while not pq.is_empty():
        dist, u = pq.remove_min()
        cloud[u] = dist

        for e in g.incident_edges(u):
            v = e.opposite(u)
            if v not in cloud:
                wgt = e.element()
                if d[u] + wgt &lt; d[v]:
                    d[v] = d[u] + wgt
                    pq.update(pqlocator[v], d[v], v)

    return cloud
</code></pre>

<p>Then, based on the returned computed shortest-path distances, we can compute <strong>shortest-path tree</strong>.
We use the same data structure that represents <strong>DFS tree</strong> and <strong>BFS tree</strong>: a map that maps a vertex to its discovery edge (edge connecting to its parent).
Because of using the same data structure, you can reuse the method <code>construct_path</code> to compute the path from one vertex to another.</p>

<pre><code class="python Compute shortest path tree">def shortest_path_tree(g: Graph, s: Vertex, d:dict) -&gt; dict:
    """ Reconstruct shortest-path tree rooted at vertex s, given the distance map d.
    Return tree as a map from vertex v -&gt; discovery edge.

    :param g: Given graph, directed or undirected.
    :param s: starting vertex.
    :param d: distance map, created from Dijkstra's algorithm.
    :return:
    """
    tree = {}

    for v in d:
        if v is not s:
            for e in g.incident_edges(v, False):
                u = e.opposite(v)
                wgt = e.element()
                if d[v] == d[u] + wgt:
                    tree[v] = e

    return tree
</code></pre>

<p>Example usage:</p>

<pre><code class="python Example usage">def test_dijkstra_algorithm(self):
    g = ExampleGraphs.airport_graph()

    vertex_map = {v.element() : v for v in g.vertices()}
    starting_vertex = vertex_map["JFK"]

    cloud = shortest_path_lengths(g, starting_vertex)

    for k, v in cloud.items():
        print("%s: %s"% (k,v))

    sp_tree = shortest_path_tree(g, starting_vertex, cloud)
    path = construct_path(vertex_map["JFK"], vertex_map["LAX"], sp_tree)

    print("Shortest path from JFK to LAX")
    for ap in path:
        print(str(ap))
</code></pre>

<pre><code class="plain Example output">Shortest path from JFK to LAX
[Vertex: JFK]
[Vertex: ORD]
[Vertex: DFW]
[Vertex: LAX]
</code></pre>

<h3>Graph in interviews and example</h3>

<p>Unfortunately, during interviews, the graph&rsquo;s underlying data structure and/or its interface provided in problems may not be the same that you see here.
You MUST be ready to change your code (e.g, DFS, BFS) to use the provided graph interface/data structure accordingly.
For example, in <a href="https://leetcode.com/problems/clone-graph/">this Leetcode problem</a>:</p>

<ul>
<li>only the root node of the graph is provided.</li>
<li>it is using adjacency list (i.e., a list of its neighbors) instead of adjacency map.</li>
<li>usually, you must do something else while traversing the graph.</li>
</ul>


<p>The modified DFS will look like this:</p>

<pre><code class="python Modified DFS">class Solution:
    def cloneGraph(self, node: 'Node') -&gt; 'Node':
        if node is None:
            return None

        to_visit = [node]
        clone = Node(node.val)
        discovered = {node: clone}  # mapping current with clone

        while to_visit:
            u = to_visit.pop()

            for v in u.neighbors:                
                if v not in discovered:
                    # new node
                    v_clone = Node(v.val)

                    discovered[v] = v_clone
                    to_visit.append(v)

                # Clone grapph
                discovered[u].neighbors.append(discovered[v])

        return clone
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Flow: Basics]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2015/04/11/network-flow-basics/"/>
    <updated>2015-04-11T18:51:41-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2015/04/11/network-flow-basics</id>
    <content type="html"><![CDATA[<p>Summary of chapter 7 &ldquo;Network Flows&rdquo; in &ldquo;Algorithm Design&rdquo; by Kleinberg &amp; Tardos.</p>

<!--more-->


<h3>Network Flow Basics</h3>

<p>Augmenting Path</p>

<pre><code class="plain Augment pseudocode">TODO
</code></pre>

<p>Ford-Fulkerson method</p>

<pre><code class="plain Ford-Fulkerson pseudocode">TODO
</code></pre>

<p>If all capacities in the flow network G are integers, then the Ford-Fulkerson method runs in O(mC) time.</p>

<h3>Capacity-Scaling Algorithm</h3>

<p>Algorithm</p>

<p>Runtime</p>

<h3>Edmonds-Karp Algorithm</h3>

<pre><code class="python Edmonds-Karp variant of Ford-Fulkerson method">def edmonds_karp(g: Graph, source: Vertex, sink: Vertex):
    """ Edmonds-Karp implementation of Ford-Fulkerson method.
    If you have an original network flow, you should create a deep copy of it AND retrieve the right source/sink vertcies.

    :param g: residual graph
    :param source: source Vertex
    :param sink: sink Vertex
    :return: maximum flow
    """

    def BFS_augment_path(g, s, t):
        """ Find BFS path from s to t in network flow graph.

        :param s: source
        :param t: sink
        :return: list of edges from s to t. Empty if there is no path.
        """
        discovered = BFS_iter(g, s)
        vertices = construct_path(s, t, discovered)
        edges = []

        if vertices:
            for i in range(len(vertices)-1):
                edges.append(g.get_edge(vertices[i], vertices[i+1]))

        return edges

    max_flow = 0
    path = BFS_augment_path(g, source, sink)

    while path:

        path_flow = min([e.element() for e in path])
        max_flow += path_flow

        for e in path:
            u, v = e.endpoints()

            # Update forward residual edge
            cur = e.element()
            if cur - path_flow == 0:
                g.delete_edge(u, v)
            else:
                e.set_element(cur - path_flow)

            # Update backward residual edge
            if g.get_edge(v, u) is None:
                g.insert_edge(v, u, path_flow)
            else:
                reverse_edge = g.get_edge(v, u)
                cur = reverse_edge.element()
                reverse_edge.set_element(cur + path_flow)

        path = BFS_augment_path(g, source, sink)

    return max_flow
</code></pre>

<h3>Blocking-Flow Algorithm</h3>
]]></content>
  </entry>
  
</feed>
