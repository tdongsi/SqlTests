<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Apple | Personal Interview Notes]]></title>
  <link href="http://tdongsi.github.io/SqlTests/blog/categories/apple/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/SqlTests/"/>
  <updated>2021-06-25T23:04:10-07:00</updated>
  <id>http://tdongsi.github.io/SqlTests/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Questions: Bit Manipulation]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2012/02/28/tutorial-bit-manipulation/"/>
    <updated>2012-02-28T00:23:25-08:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2012/02/28/tutorial-bit-manipulation</id>
    <content type="html"><![CDATA[<h3>Questions</h3>

<ol>
<li>Addition using only bit manipulation.</li>
<li>Subtraction using only bit manipulation.</li>
<li>Odd Man Out: Given an unsorted array of integers where every integer appears exactly twice, except for one integer which appears once. Find the odd one out.</li>
<li>Quickly determine if a number is a power of 2 (i.e., n = 2<sup>x</sup>).</li>
<li>What is big-endian? What is little-endian?</li>
<li>How would you determine if the system is big-endian or little-endian.</li>
<li>Isolate the right-most 1 bit in <code>x</code>.</li>
<li>Hamming Weight of an integer x (Hamming distance of x and 0).</li>
<li>Java: Write a function to calculate the absolute value of a 32-bit integer without branching.</li>
<li>Hamming Distance of two integers a and b.</li>
</ol>


<!--more-->


<h3>Answers</h3>

<p>(1) <a href="http://stackoverflow.com/questions/4068033/add-two-integers-using-only-bitwise-operators">Addition</a>: Recursive formula <code>x + y = (x ^ y) + (x &amp; y) &lt;&lt; 1</code> is the most easy to understand.
In code, it is implemented as follows:</p>

<pre><code class="java Addition">    private int add(int a, int b) {
        if(b == 0)
            return a;

        return add( a ^ b, (a &amp; b) &lt;&lt; 1);
    }
</code></pre>

<p>(2) <a href="http://www.geeksforgeeks.org/subtract-two-numbers-without-using-arithmetic-operators/">Subtraction</a>: The recursive formula is <code>x - y = (x ^ y) - (~x &amp; y) &lt;&lt; 1</code>.
In code, it is implemented as follows:</p>

<pre><code class="java Subtraction">    private int subtract(int a, int b) {
        if(b == 0)
            return a;

        return subtract( a ^ b, (~a &amp; b) &lt;&lt; 1);
    }
</code></pre>

<p>(3) Find odd one.</p>

<p>XOR all the values of the array together. <code>a XOR a = 0</code>.</p>

<p>(4) Quickly determine if a number is a power of 2.</p>

<p>If x == 0, return False. Then, check <code>x &amp; (x-1) == 0</code>.</p>

<p>(5) Big-endian stores the most significant byte first, while little-endian stores the least significant byte first.
Fields in the protocols of the Internet protocol suite, such as IPv4, IPv6, TCP, and UDP, are transmitted in big-endian order.
For this reason, big-endian byte order is also referred to as network byte order.</p>

<p>(6) Use union type in C. Then check it based on definition.</p>

<pre><code class="c Check endianess">union Data
{
int i;
char str[2];
} data;

data.i = 0x00ff;
printf( "data.str[0]: %d\n", data.str[0]);
</code></pre>

<p>Or use <a href="https://linux.die.net/man/3/htonl"><code>htonl</code></a> function (Host TO Network Long) in Linux.
If outputs are the same as inputs, it is big-endian since data is transmitted in big-endian order in many Internet protocols.</p>

<p>(7) <code>x &amp; ~(x-1)</code>.</p>

<p>(8)</p>

<pre><code class="python Hamming weight">def hamming_weight(x: int) -&gt; int:
    """ Hamming weight is effectively Hamming distance between x and 0.
    """
    count = 0

    while x != 0:
        # increment the cound
        count += 1
        # clear the least significant bit
        x &amp;= x - 1

    return count
</code></pre>

<p>(9)</p>

<pre><code class="java Absolute without branching">public int abs(int num) {
    // mask will be all 1s for negative, all 0s for positive
    int mask = num &gt;&gt; 31

    // Effectively: if num &lt; 0
    // Toggle the bits and add 1. 
    // For two's complement format. All 1s = -1
    return num ^ mask - mask
}
</code></pre>

<p>(10)</p>

<pre><code class="python Hamming distance">def hamming_distance_int(x: int, y: int) -&gt; int:
    diff = x ^ y
    count = 0

    while diff != 0:
        # increment the cound
        count += 1
        # clear the least significant bit
        diff &amp;= diff - 1

    return count
</code></pre>
]]></content>
  </entry>
  
</feed>
