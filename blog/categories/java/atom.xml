<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Personal Interview Notes]]></title>
  <link href="http://tdongsi.github.io/SqlTests/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/SqlTests/"/>
  <updated>2021-06-26T00:10:16-07:00</updated>
  <id>http://tdongsi.github.io/SqlTests/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tutorial: Process Synchronization]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2016/06/02/tutorial-process-synchronization/"/>
    <updated>2016-06-02T00:35:03-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2016/06/02/tutorial-process-synchronization</id>
    <content type="html"><![CDATA[<p>Summary of chapter 5 of &ldquo;Operating System concepts&rdquo; (Dinosaur book).
Topics in this chapter are the most intensive and frequently asked during interviews.</p>

<!--more-->


<p>This chapter discuss how to prevent concurrent access to shared data that may result in data inconsistency.</p>

<h3>5.1 &amp; 5.2: Critical section</h3>

<p>Consider the producer–consumer problem, which is representative of
operating systems. Specifically, in Section 3.4.1, we described how a bounded
buffer could be used to enable processes to share memory.</p>

<pre><code class="cpp Producer process">while (true ) {

  /* produce an item in next produced */
  while (counter == BUFFER SIZE )
    ; /* do nothing */

  buffer[in] = next produced;
  in = (in + 1) % BUFFER SIZE ;
  counter++;
}
</code></pre>

<pre><code class="cpp Consumer process">while (true ) {
  while (counter == 0)
    ; /* do nothing */

  next consumed = buffer[out];
  out = (out + 1) % BUFFER SIZE ;
  counter--;
  /* consume the item in next consumed */
}
</code></pre>

<p>The above code works incorrectly in multi-thread or process situation, due to parallel modifications to &ldquo;counter&rdquo;.
When several processes access and manipulate the same data concurrently and the
outcome of the execution depends on the particular order in which the access
takes place, is called a race condition.</p>

<p>Critical section: No two processes are executing in their critical sections at the same time.
Solution to a critical section problem requires:
Mutual exclusion: only one process in CS at a time.
Progress: Selection process should not be postponed indefinitely.
Bounded waiting: once a process request to enter, waiting time is bounded.</p>

<p>Nonpreemptive kernel does not allow a process running in kernel mode to be
preempted; a kernel-mode process will run until it exits kernel mode, blocks,
or voluntarily yields control of the CPU. A nonpreemptive kernel is essentially free from race conditions.
A preemptive kernel may be more responsive, since there is less risk that a
kernel-mode process will run for an arbitrarily long period.</p>

<h3>5.3: Peterson&rsquo;s algorithm</h3>

<pre><code class="cpp Peterson's algorithm">flag[i] = true
turn = j

while ( flag[j] &amp;&amp; turn == j ) {
}

// start of CS

// end of CS
flag[i] = false flag[j] = true
turn = i

while( flag[i] &amp;&amp; turn == i ) {
}

// start of CS

// end of CS
flag[j] = false
</code></pre>

<p>NOTE: <a href="http://en.wikipedia.org/wiki/Peterson's_algorithm">Peterson’s algorithm</a> is restricted to two processes.
Filter algorithm: Peterson&rsquo;s algorithm for N processes
The filter algorithm generalizes Peterson&rsquo;s algorithm for N processes. It uses N different levels - each represents another &lsquo;waiting room&rsquo;, before the critical section. Each level will allow at least one process to advance, while keeping one process in waiting.</p>

<p><a href="http://cs.stackexchange.com/questions/12621/understanding-peterson-s-and-dekker-s-algorithms">http://cs.stackexchange.com/questions/12621/understanding-peterson-s-and-dekker-s-algorithms</a>
Both processes indicates if the other want to enter CS, it can proceed. If both processes enter at the same time, turn will be set to i and j at the same time, and only one will last.
Proof of bounded waiting: Pi will enter the CS after at most one entry by Pj.</p>

<pre><code class="plain Analogies of Peterson's algorithm">Peterson's: "I want to enter."                 flag[0]=true;
            "You can enter next."              turn=1;
            "If you want to enter and          while(flag[1]==true&amp;&amp;turn==1){
            it's your turn I'll wait."         }
            Else: Enter CS!                    // CS
            "I don't want to enter any more."  flag[0]=false;

Dekker's:   "I want to enter."                 flag[0]=true;
            "If you want to enter              while(flag[1]==true){
             and if it's your turn               if(turn!=0){
             I don't want to enter any more."      flag[0]=false;
            "If it's your turn                     while(turn!=0){
             I'll wait."                           }
            "I want to enter."                     flag[0]=true;
                                                 }
                                               }
            Enter CS!                          // CS
            "You can enter next."              turn=1;
            "I don't want to enter any more."  flag[0]=false;
</code></pre>

<h3>5.4: Sync using hardware</h3>

<p>Protect critical section by locking.</p>

<p>Many modern computer systems therefore provide special hardware
instructions that allow us either to test and modify the content of a word or
to swap the contents of two words atomically—that is, as one uninterruptible unit.</p>

<p>Atomic test_and_set() and compare_and_swap() for locking:</p>

<pre><code class="c">boolean test_and_set(boolean *target) {
  boolean rv = *target;
  *target = true;
  return rv;
}

int compare_and_swap(int *value, int expected, int new value) {
  int temp = *value;
  if (*value == expected)
      *value = new value;
  return temp;
}
</code></pre>

<p>Simple Mutex with atomic test_and_set()
Figure 5.5</p>

<p>Bounded-Waiting mutex with atomic test_and_set(): data structure and algorithm
Figure 5.7</p>

<h3>5.5: Mutex locks</h3>

<p>We use the mutex to lock to protect critical regions and thus prevent race conditions.</p>

<p>Calls to either acquire() or release() must be performed atomically.</p>

<pre><code class="c">acquire() {
  while (!available)
    ; /* busy wait */
  available = false;
}

release() {
  available = true;
}
</code></pre>

<p>Usage:</p>

<pre><code class="c">acquire()

// start of CS

// end of CS

release()
</code></pre>

<p>The main disadvantage of the implementation given here is that it requires busy waiting. This type of mutex lock is also called a spinlock.
Spinlocks do have an advantage, however, in that no context switch is required.</p>

<h3>5.6: Semaphores</h3>

<p>A semaphore S is an integer variable that, apart from initialization, is
accessed only through two standard atomic operations: wait() and signal().</p>

<pre><code class="c">wait(S) {
  while (S &lt;= 0 )
    ; // busy wait
  S--;
}

signal(S) {
  S++;
}
</code></pre>

<p>The value of a counting semaphore can range over an unrestricted domain. Versus binary semaphore, which is similar to mutex.
Counting semaphores can be used to control access to a given resources of a finite number of instances.</p>

<p>We can also use semaphores to solve various synchronization problems.
For example,consider two concurrently running processes: P1 with a statement
S1 and P2 with a statement S2 . Suppose we require that S2 be executed only
after S1 has completed. We can implement this scheme readily by letting P1
and P2 share a common semaphore synch, initialized to 0. In process P1 , we
insert the statements</p>

<pre><code class="c">S1;
signal(synch);
</code></pre>

<p>In process P2 , we insert the statements</p>

<pre><code class="c">wait(synch);
S2;
</code></pre>

<p>Because synch is initialized to 0, P2 will execute S2 only after P1 has invoked
signal(synch) , which is after statement S1 has been executed.</p>

<p>Deadlock:</p>

<pre><code>P 0 P 1
wait(S); wait(Q);
wait(Q); wait(S);
. .
. .
. .
signal(S); signal(Q);
signal(Q); signal(S);
</code></pre>

<p>Priority inversion:</p>

<p>The problem of priority inversion is when three processes of different priorities L &lt; M &lt; H. H is waiting for L to finish with a certain resource. M process becomes runnable and preempts L. Indirectly, process M with lower priority affects how long process H must wait for resource.
It occurs when the system has more than two priorities. However, it is almost always the case.</p>

<p>Solution: priority-inheritance protocol: all processes that use a resource, waited by a higher priority process, will inherit the highest priority until they are done with the resource.</p>

<h4>Semaphore implementation</h4>

<p>The naive definition of wait() and signal() above presents the same problem of busy waiting.
In actual implementation, when a process execute wait() operation and find that semaphore value is not positive, it must wait. However, instead of busy waiting, the process block itself.
In this implementation, semaphore values may be negative, while they are never negative in classical definition with busy waiting. If a semaphore value is negative, its magnitude indicates the number of waiting processes (note different order of decrement in wait()).</p>

<p>It is critical that semaphore operations be executed atomically: no two processes can execute wait() and signal() operations on the same semaphore at the same time.
In a multiprocessor environment, usually compare_and_swap() or spin locks are used to ensure wait() and signal() are atomic.
So, we admit that busy waiting is NOT eliminated in this implementation. However, busy waiting is limited to CS of the wait() and signal() operations. These CSs are short (about 10 instructions). Thus, CS is almost never occupied, and busy waiting is rare and short, if ever happens.</p>

<h3>5.7: Classic Problems of Synchronization</h3>

<p>Use semaphores for synchronization. Actual implementation can use mutex instead of binary semaphore.</p>

<p>Bounded-Buffer (Consumer-Producer) problem
Problem: See 5.1.
Solution: The producer and consumer share the following data structure:
The mutex is used to provide mutual exclusion for accesses to the buffer pool.</p>

<pre><code class="c">int n;
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0

// Producer
do {
. . .
/* produce an item in next produced */
. . .
wait(empty);
wait(mutex);
. . .
/* add next produced to the buffer */
. . .
signal(mutex);
signal(full);
} while (true);

// Consumer
do {
wait(full);
wait(mutex);
. . .
/* remove an item from buffer to next consumed */
. . .
signal(mutex);
signal(empty);
. . .
/* consume the item in next consumed */
. . .
} while (true);
</code></pre>

<p>Reader-Writer problem:
Writers should have exclusive access while writing to the shared database.
There are several variants of “reader-writer” problems:
First problem: No reader to be kept waiting unless a writer has already obtained accesss.
Second problem: Once writer is ready, that writer perform its write ASAP. No new readers may start reading.
A solution to either problem may result in starvation.</p>

<p>Solution to first reader-writer problem: shared data structure
semaphore rw_utex = 1;
semaphore mutex = 1;
int read count = 0;
The mutex semaphore is used to ensure mutual exclusion when the variable read count is updated.
The read count variable keeps track of how many processes are currently reading the object.
The semaphore rw_mutex functions as a mutual exclusion semaphore for the writers.</p>

<pre><code class="c">// Writer   
do {
wait(rw mutex);
. . .
/* writing is performed */
. . .
signal(rw mutex);
} while (true);

// Reader
do {
wait(mutex);
read count++;
if (read count == 1)
wait(rw mutex);
signal(mutex);
. . .
/* reading is performed */
. . .
wait(mutex);
read count--;
if (read count == 0)
signal(rw mutex);
signal(mutex);
} while (true);
</code></pre>

<p>Dining Philosopher problem: This solution can create a deadlock</p>

<pre><code class="c">semaphore chopstick[5];

do {
wait(chopstick[i]);
wait(chopstick[(i+1) % 5]);
. . .
/* eat for awhile */
. . .
signal(chopstick[i]);
signal(chopstick[(i+1) % 5]);
. . .
/* think for awhile */
. . .
} while (true);
</code></pre>

<p>Several possible remedies to the deadlock problem are replaced by:</p>

<ul>
<li>Allow at most four philosophers to be sitting simultaneously at the table.</li>
<li>Allow a philosopher to pick up her chopsticks only if both chopsticks are
available (to do this, she must pick them up in a critical section).</li>
<li>Use an asymmetric solution—that is,an odd-numbered philosopher picks
up first her left chopstick and then her right chopstick, whereas an even-
numbered philosopher picks up her right chopstick and then her left
chopstick.</li>
</ul>


<p>In 5.8, we use monitor (equivalent to a waiter to tell which philosopher should eat) to provides deadlock-free solution.
A deadlock-free solution does not necessarily eliminate the possibility of starvation.</p>

<h3>5.8: Monitors</h3>

<p>Semaphore is not a complete solution. If a single process is not well-behaved (semaphore used incorrectly), the system break down.
Incorrect order of signal() and wait(): mutual exclusion is no longer guaranteed.
wait() is used in place of signal(): a deadlock may occur.
wait() or signal() or both are omitted: mutual exclusion violated or deadlock.</p>

<p>Syntax of a monitor:</p>

<p>Local variables of a monitor can be accessed by only the local functions. Only one process at a time is active within the monitor.
We also defines condition construct: condition x, y; // condition variables
The only operations that can be invoked on a condition variable are wait() and signal().
The operation x.wait(); means that the process invoking this operation is suspended until another process invokes x.signal();
The x.signal() operation resumes exactly one suspended process. If no process is suspended, then the signal() operation has no effect.
(Different from semaphore’s signal(): semaphore() signal always change the state of semaphore, condition’s signal() may not).</p>

<p>Dining Philosophers solution using Monitors:
Monitor is acting like a waiter/moderator. Before a philosopher starts eating, she informs the waiter (invoked operation pickup()) and the waiter will tell her what to do.
After she is done eating, she again informs the waiter (putdown()). It is still possible that some philosopher will starve to death.</p>

<p>Resuming Processes within a Monitor
One simple solution is to use FIFO ordering.
Another solution is conditional-wait construct, with c is the priority number input.
x.wait&copy;;
When x.signal() is executed, the process with the smallest priority number is resumed next.</p>

<p>Java monitors
Java uses monitor for thread synchronization.
Every object in Java has a single lock associated with it. When a method is declared synchronized, calling the method requires owning the lock of the object.
If the lock is not available, the synchronized method is placed in the entry set for the object’s lock.
The Java Object class’s method wait() and notify() are similar to wait() and signal() statements for a monitor.</p>

<h3>Reference</h3>

<ul>
<li><a href="/download/Java_Concurrency.pdf">Java Concurrency</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classic Interview Questions]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2011/01/21/classic-interview-questions/"/>
    <updated>2011-01-21T15:18:42-08:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2011/01/21/classic-interview-questions</id>
    <content type="html"><![CDATA[<p>There are reasons that these interview questions are just popular.
The goal is not to fail at the same question TWICE.</p>

<!--more-->


<h3>Maximum subarray</h3>

<p>TODO: Maximum subarray should be the main problem and &ldquo;buying stock&rdquo; should be the derivative problem.</p>

<pre><code class="python ">def buy_stock(prices:list) -&gt; Tuple[int, int, int]:
    """Find when to buy and sell to maximize profit from list of stock prices"""
    profit, buy, sell = 0, 0, 0
    min_price, min_idx = prices[0], 0

    for i in range(1, len(prices)):
        if prices[i] - min_price &gt; profit:
            profit = prices[i] - min_price
            buy, sell = min_idx, i

        if prices[i] &lt; min_price:
            min_price, min_idx = prices[i], i

    return profit, buy, sell


def maximum_subarray(numbers:list) -&gt; list:
    """ Largest Sum Contiguous Subarray.
    https://en.wikipedia.org/wiki/Maximum_subarray_problem
    """
    total = 0
    accu = []  # accumulated sum of "numbers"

    for num in numbers:
        total += num
        accu.append(total)

    max_val, start, end = buy_stock(accu)

    print(max_val)

    return numbers[(start+1):(end+1)]
</code></pre>

<h3>Largest rectangle under histogram</h3>

<p>The stack-based solution is <code>O(n)</code>.
There is another solution which is divide-and-conquer and more intuitive that runs in <code>O(n logn)</code>.</p>

<pre><code class="python Largest rectangle">def largest_rect_histogram(heights: list) -&gt; int:
    stack = []
    max_area = 0

    for idx, e in enumerate(heights):
        save_idx = idx
        while stack:
            # peek top of the stack
            peek_idx, peek_height = stack[-1]
            if e &lt; peek_height:
                stack.pop()
                save_idx = peek_idx

                temp = peek_height * (idx - peek_idx)
                if max_area &lt; temp:
                    max_area = temp
            else:
                break

        # push back the current bar
        stack.append((save_idx, e))

    # Handle the bars still in the stack
    idx = len(heights)
    while stack:
        peek_idx, peek_height = stack.pop()
        temp = peek_height * (idx - peek_idx)
        if max_area &lt; temp:
            max_area = temp

    return max_area
</code></pre>

<h3>Merge intervals</h3>

<p>Given a collection of intervals (start, end), merge all overlapping intervals.</p>

<p>Example: <code>[[1, 4], [4, 5], [3, 4]] -&gt; [[1, 5]]</code></p>

<pre><code class="python Merge intervals">def merge_intervals(mlol):
    """ Given a collection of intervals, merge all overlapping intervals.

    :param mlol: List of lists
    :return: overlapping intervals.
    """
    mlol.sort(key=lambda x: x[0])

    output = []
    for interval in mlol:
        # if the output list is empty or if the current interval does not overlap with the previous,
        # simply append it.
        if not output or output[-1][1] &lt; interval[0]:
            output.append(interval)
        else:
            # otherwise, there is overlap, so we combine the current and previous intervals.
            output[-1][1] = max(output[-1][1], interval[1])

    return output
</code></pre>

<h3>How to implement a hash map</h3>

<p><a href="https://www.geeksforgeeks.org/internal-working-of-hashmap-java/">https://www.geeksforgeeks.org/internal-working-of-hashmap-java/</a></p>

<p>Main ideas:</p>

<ul>
<li>ArrayList of LinkedList of Entry (Key, Value).</li>
<li>Convert hashcode of Key to integer index (H % bucket).</li>
<li>Use index to move in array.</li>
<li>Use Key to find entry in LinkedList.</li>
</ul>


<h3>Reverse linked list. Find cycle in linked list</h3>

<p>The first problem &ldquo;reversing a linked list&rdquo; used to be the &ldquo;foobar&rdquo; challenge, although slightly harder.
They just want to check if you know the most basic stuffs.
Now, they are usually used as a warm-up question.
However, there is a reason for &ldquo;foobar&rdquo; challenges since reversing linked list can be tricky with corner cases even for experienced but ill-prepared candidates.
In addition, if you are interviewing for senior positions, they expect you to solve this question quickly (as if you do interview every single day).
So, you usually have no choice but make sure that you can do this problem quickly.</p>

<pre><code class="python Reverse linked list">def reverse_list(head:Node) -&gt; Node:
    """ Write a function that reverses a linked list
    :param head: The head of the linked list.
    :return: The new head of the reversed list.
    """
    prev = None
    cur = head

    while cur is not None:
        temp = cur
        cur = cur.get_next()
        temp.set_next(prev)
        prev = temp

    return prev
</code></pre>

<p>Check if there is a cycle in a linked list.
TODO: Floyd algorithm.</p>

<h3>LRU Cache</h3>

<p>The LRU cache can be easily implemented in Java using LinkedHashMap.
There is a <code>protected</code> method that allow you to override to specify the cache size.
TODO: that method.</p>

<p>In Python, the natural equivalent to Java&rsquo;s LinkedHashMap is OrderedDict.
In fact, one implementation of LRU cache can be as follows:</p>

<pre><code class="python LRU cache">class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = collections.OrderedDict()

    def get(self, key):
        try:
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
        except KeyError:
            return None

    def set(self, key, value):
        try:
            self.cache.pop(key)
        except KeyError:
            if len(self.cache) &gt;= self.capacity:
                self.cache.popitem(last=False)
        self.cache[key] = value
</code></pre>

<h3>Singleton design pattern</h3>

<p>This question seems to be common because it shows that if a candidate knows “design pattern”, best practices, concurrency (<code>synchronized</code>, <code>volatile</code> keywords), and <code>enum</code> (newer, less common Java features).
It also involves lazy initialization and performance, leaving opportunities to drill further.</p>

<h4>Standard Singleton</h4>

<p>According to &ldquo;Effective Java&rdquo; book, the best way to implement Singleton is to use single-item <code>enum</code>.</p>

<pre><code class="java Singeton with example attribute, constructor, and method.">enum OnlyOneOfMe {
    SINGLETON("King");

    private String title;

    OnlyOneOfMe(String title) {
        this.title = title;
    }

    public String sayHello() {
        return "Hello";
    }
}
</code></pre>

<p>Interviewers while appreciating that you know <code>enum</code> and best practices, they won&rsquo;t let you go easily.
They will ask how it is implemented under the hood or using the older version.
Then, you should provide the standard idiom with lazy initialization and private constructor.</p>

<pre><code class="java Singleton with private constructor">public class OnlyOneOfMe {
    private static OnlyOneOfMe singleton = null;

    private OnlyOneOfMe() {
        // init code
    }

    public static OnlyOneOfMe getSingleton() {
        if (singleton == null) {
            singleton = new OnlyOneOfMe();
        }
        return singleton;
    }
}
</code></pre>

<p>The common follow-up question is to ask whether if it is thread-safe.
You should be able to point out that since there are write operations on <code>singleton</code> variable, it is not thread-safe if many threads call <code>getSingleton</code> method.
To make it thread-safe (the next question), the simple fix is to add <code>synchronized</code> keyword to the function.</p>

<pre><code class="java">public synchronized static OnlyOneOfMe getSingleton() {
    ...
}
</code></pre>

<p>If you come this far, the next question is whether it is fast.
You should be able to point out that since there are locking at &ldquo;getSingleton&rdquo; method, it will be a bottleneck when many threads want to get the singleton instance.
The next subsection will address the best ways to do lazy initialization for performance.
However, it is shown here for completeness.</p>

<pre><code class="java Lazy initialization for performance">public class OnlyOneOfMe {
    private static class SingletonHolder {
        static final OnlyOneOfMe singleton = new OnlyOneOfMe();
    }

    private OnlyOneOfMe() {
        // init code
    }

    public static OnlyOneOfMe getSingleton() {
        return SingletonHolder.singleton;
    }
}
</code></pre>

<h4>Lazy initialization and Performance</h4>

<p>According to <a href="http://www.oracle.com/technetwork/articles/javase/bloch-effective-08-qa-140880.html">Bloch (&ldquo;Effective Java&rdquo; author)</a>, the single most important piece of advice is &ldquo;Don&rsquo;t do it unless you need to.&rdquo; The great majority of your initialization code should look like this:</p>

<pre><code class="java">// Normal initialization, not lazy!
private final FieldType field = computeFieldValue();
</code></pre>

<p>If you need lazy initialization for correctness &ndash; but not for performance &ndash; just use a <code>synchronized</code> accessor. It&rsquo;s simple and clearly correct.</p>

<p>If you need better performance, your best choice depends on whether you&rsquo;re initializing a static field or an instance field. If it&rsquo;s a static field, use the lazy initialization holder class idiom:</p>

<pre><code class="java Singleton static field.">// Lazy initialization holder class idiom for static fields
private static class FieldHolder {
     static final FieldType field = computeFieldValue();
}
static FieldType getField() { return FieldHolder.field; }
</code></pre>

<p>This idiom is almost magical. There&rsquo;s synchronization going on, but it&rsquo;s invisible.
The Java Runtime Environment does it for you, behind the scenes.
And many VMs actually patch the code to eliminate the synchronization once it&rsquo;s no longer necessary, so this idiom is extremely fast.</p>

<p>If you need high-performance lazy initializing of an instance field, use the double-check idiom with a volatile field.
This idiom wasn&rsquo;t guaranteed to work until release 5.0, when the platform got a new memory model.
The idiom is very fast but also complicated and delicate, so don&rsquo;t be tempted to modify it in any way.
Just copy and paste &ndash; normally not a good idea, but appropriate here:</p>

<pre><code class="java Double-check idiom for Singleton instance fields.">// Double-check idiom for lazy initialization of instance fields.
private volatile FieldType field;
FieldType getField() {
    FieldType result = field;
    if (result == null) { // First check (no locking)
        synchronized(this) {
            result = field;
            if (result == null) // Second check (with locking)
                field = result = computeFieldValue();
        }
    }
    return result;
}
</code></pre>

<h4>References</h4>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java">Double-checked locking</a></li>
<li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">Analysis of idiom before Java 1.5</a></li>
<li><a href="http://www.oracle.com/technetwork/articles/javase/bloch-effective-08-qa-140880.html">Bloch&rsquo;s interview</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compare Languages: Java vs. C++]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2011/01/11/compare-languages-java-vs-c-plus-plus/"/>
    <updated>2011-01-11T10:11:40-08:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2011/01/11/compare-languages-java-vs-c-plus-plus</id>
    <content type="html"><![CDATA[<p>How to answer the question &ldquo;What is the difference between Java and C++?&rdquo;.
Knowing the subtle difference between similar languages shows mastery of both.</p>

<!--more-->


<h3>Strict differences</h3>

<p>Java</p>

<ol>
<li>Multiple inheritance: by implementing multiple interfaces, only extending one superclass.</li>
<li>Java is reflective, allowing dynamic code generation.</li>
<li>Automatic garbage collection. The concept of destructor and using finalize() is not recommended.</li>
<li>Operator overloading is not possible [2]. Only + overladed for String.</li>
<li>Generic programming: syntactic sugar for backward compatibility (can be removed), just a wrapper for object casting.</li>
</ol>


<p>C++</p>

<ol>
<li>Extending multiple classes are allowed</li>
<li>C++ provides only object types and class name.</li>
<li>Explicit memory allocation and deallocation.</li>
<li>Operator overloading is very common.</li>
<li>Advanced version of preprocessor/macro programming.</li>
</ol>


<h3>Practical differences</h3>

<p>In practice, the patterns of using two languages can be very different.</p>

<p>Java</p>

<ol>
<li>Using Interfaces and Listeners to achieve similar effects.</li>
<li>final has more limited usage.</li>
<li>Label can be used in loops, such as break from nested <code>for</code> loops.</li>
<li>Most libraries are based on class inheritance and object-oriented programming.</li>
</ol>


<p>C++</p>

<ol>
<li>Function pointers, function objects are common.</li>
<li>const keyword has more functions and is more commonly used.</li>
<li>goto statement is supported but not recommended.</li>
<li>Most libraries are based on templates and generic programming.</li>
</ol>


<p>Java Generics are massively different to C++ templates.
Basically in C++ templates are basically a glorified preprocessor/macro set.
Java Generics are basically syntactic sugar (things can be removed from the language, added just to make expressions more clearly)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Index]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2011/01/02/language-index/"/>
    <updated>2011-01-02T09:07:55-08:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2011/01/02/language-index</id>
    <content type="html"><![CDATA[<p>Overview of most common languages.</p>

<h3><a href="https://tdongsi.github.io/java/">Java</a></h3>

<h4>Pure Java</h4>

<p>Questions:</p>

<ol>
<li>What is OOP? What is polymorphism? etc.</li>
<li>Some standard design patterns in Java: Singleton (enum and two locks), Builder, Decorator, Factory.</li>
<li>Examples of design patterns in Java.</li>
<li>Relations between <code>hashCode()</code> and <code>equals()</code>.</li>
<li>Implements a simple algorithm for <code>hashCode()</code>.</li>
<li>When to use <code>finalize()</code> and when not to use <code>finalize()</code>. See &ldquo;Effective Java&rdquo;.</li>
<li>Java concurrency: what is <code>volatile</code>? when to use it? <code>synchronized</code>?</li>
<li>Some legacy items: Diff between StringBuilder vs StringBuffer.</li>
</ol>


<h4>Groovy</h4>

<h4>Tools and Ecosystem</h4>

<h3><a href="https://tdongsi.github.io/python/">Python</a></h3>

<ul>
<li><a href="https://docs.python.org/3/whatsnew/3.0.html">What&rsquo;s new in Python 3</a>

<ul>
<li>Essential: Maybe only Python 2 is supported in interviews while you&rsquo;ve been using Python 3 or vice versa. Learn this to unblock yourself.</li>
<li>Bonus points to explain that to interviewers.</li>
</ul>
</li>
</ul>


<p>Warm-up question 1: Write a function that reads file numbers.txt and outputs numbers-mult.txt where each number in numbers.txt is multiplied by its line number, starting from 1.</p>

<pre><code class="python Warm up exercise">def mult_file(INFILE='numbers.txt', OUTFILE='numbers-mult.txt'):
    try:
        with open(INFILE, 'r') as infile, open(OUTFILE, 'w') as outfile:
            for count, line in enumerate(infile, 1):
                line.strip()
                if line:
                    out = count * int(line)
                    outfile.write("%d\n" % out)
    except IOError as e:
        print("Can't open files %s" % e)
</code></pre>

<p>This is a good warm-up exercise for Python since it touches many common operations in Python: reading from/writing to files, string to int.
It is aslo not trivial to write Pythonic code for it.</p>

<p>Warm-up question 2: You are given a search string and a magazine.
You seek to generate all the characters in search string by cutting them out from the magazine.
Give an algorithm to efficiently determine whether the magazine contains all the letters in the search string.</p>

<pre><code class="python Text from magazine">def create_text_from_magazine(text, magazine):
    """ Create search string from magazines.
    :param text: Text you want to generate.
    :param magazine: Where you get characters from.
    :return: True or False
    """
    from collections import Counter

    text_count = Counter(text.strip().lower())
    del text_count[' ']  # We don't care about spaces

    lines = magazine.split("\n")
    for line in lines:
        mag_count = Counter(line.strip().lower())
        text_count -= mag_count
        # print(text_count)
        if not text_count:
            return True

    return False
</code></pre>

<p>Question 3: Define abstract class in Python.</p>

<pre><code class="python Abstract class">from abc import ABCMeta, abstractmethod

class Sequence(metaclass=ABCMeta):
    """Simulate collections.Sequence"""

    @abstractmethod
    def __len__(self):
        """Return the length of the sequence"""

    @abstractmethod
    def __getitem__(self, j):
        """Return the element at index j"""

    def __contains__(self, item):
        """Concrete behavior based on abstract methods"""
        for j in range(len(self)):
            if self[j] == item:
                return True

        return False
</code></pre>

<p>Question 4: Write a generator that returns factors of an integer.</p>

<pre><code class="python Generator">def factors(n):
    """ Generator of factors for n
    """
    if n &lt; 1:
        raise ValueError("n must be larger than 0")

    k = 1
    while k*k &lt; n:
        a, b = divmod(n, k)

        if b == 0:
            yield k
            yield a

        k += 1

    if k*k == n:
        yield k
</code></pre>

<h3><a href="https://tdongsi.github.io/javascript/">JavaScript</a></h3>

<h3>Next language?</h3>

<ul>
<li>Golang</li>
<li>Ruby</li>
</ul>


<!--more-->


<h3>Java Answers</h3>

<ol>
<li>Know your audience.
A new grad will mention something about abstraction, polymorphism, inheritance, encapsulation (A PIE) and pass.
Alan Kay (father of OOP) will say something about message passing and late binding and might fail.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tutorial: Test-Driven Development]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2011/01/01/tutorial-test-driven-development/"/>
    <updated>2011-01-01T21:57:00-08:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2011/01/01/tutorial-test-driven-development</id>
    <content type="html"><![CDATA[<!-- Reference:
Evernote: "QE cheat sheet"
-->


<p>Test-driven development has become more and more important.
As pointed out in <a href="/syllabus/">this</a>, candidates with 3+ years of industry experience should be able to demonstrate testing experience.
You should expect testing questions come up, even when you interview for developer positions.</p>

<!--more-->


<h3>Type of tests</h3>

<p>This is useful for the open questions of &ldquo;How do you test X?&rdquo; type.
X can be anything that are not related to software.
It would be awesome if you can come up with a creative test case that interviewers won&rsquo;t think of.
However, you are usually expected to hit broadly and methodically different categories of tests, instead of keeping listing different test cases of a test category.
Knowing these kind of tests can also help you keep talking without running out of ideas.</p>

<ul>
<li>Unit testing</li>
<li>Integration testing</li>
<li>Functional testing</li>
<li>Load testing</li>
<li>Stress testing</li>
<li>Performance testing</li>
<li>Install/Uninstall testing</li>
<li>UI testing</li>
<li>Localization testing (language, market-ready)</li>
<li>Security testing</li>
<li>Acceptance testing</li>
<li>Regression testing</li>
</ul>


<p>Other general types:</p>

<ul>
<li>White-box testing</li>
<li>Black-box testing</li>
<li>Beta testing</li>
</ul>


<p>Questions that I will ask myself if I am the interviewer.</p>

<ul>
<li>Does the candidate ask good questions to understand the feature or he/she just simply making assumptions?</li>
<li>Is the candidate covering negative and boundary conditions?</li>
<li>Is the candidate trying to break the feature? Any interesting test cases you haven’t thought of?</li>
<li>Is the candidate covering non-functional tests such as performance, scalability, security, etc.?</li>
</ul>


<p>Make sure that you pass all those minimum expections: ask clarifying questions and highlight assumptions.</p>

<h3>Example of a testing question</h3>

<p>For example, the interviewer will give you a question: &ldquo;Given a string, reverse it word by word&rdquo;.
You proceed to solve it and write it on the whiteboard.
The follow-up question would be &ldquo;How would you test it?&rdquo;.</p>

<p>(1) General</p>

<ul>
<li>&ldquo;Hello World&rdquo; => &ldquo;World Hello&rdquo;</li>
<li>&ldquo;Foo Bar Baz&rdquo; => &ldquo;Baz Bar Foo&rdquo;</li>
<li>What happens with unicode?</li>
<li>What about tabs and newlines? Do newlines end up in the beginning or end?</li>
<li>What about unicode whitespace?</li>
<li>What about numbers? What about special characters like ! and #.</li>
</ul>


<p>(2) Boundary</p>

<ul>
<li>Null string: null => what happens?</li>
<li>Empty string: &ldquo;&rdquo; => &ldquo;&rdquo;</li>
<li>Really long string => What happens?</li>
<li>What about a one really really long word?</li>
<li>What if you just give a string of spaces <code>"     "</code> => <code>"     "</code>?</li>
<li>What if you give a really string of letters separated by spaces? <code>"a a a a a a a a a a a a a a a a a a aa a"</code></li>
<li>Does it handle Chinese well?</li>
<li>What if there&rsquo;s multiple spaces? Are they respected? <code>"a a a b ob"</code></li>
</ul>


<p>(3) Exceptional</p>

<ul>
<li>What happens when you give a really long string (like from <code>/dev/random</code>)?</li>
<li>How can the function run out of memory?</li>
<li>What if the type is incorrect? Could happen in Python.</li>
<li>null => depends on specification. Might not be possible in languages like Haskell.</li>
</ul>


<p>Four and five are bonus stuff that I like to cover or have been asked of me in the past.
They generally aren&rsquo;t the first three that I think of when I&rsquo;m asked to test a function though.</p>

<p>(4) Performance - Running time</p>

<p>I would explain the space complexity I expect out of my solution.
I would draw a simple graph of what it would probably look like.
I would then provide a set of sample points that I would take to see the space complexity.
Some sample points I would take are 0, 1, 5, 10, <code>100</code>, <code>1,000</code>, <code>10,000</code>, <code>100,000</code>, <code>1,000,000</code> until I hit some barrier and then draw more fine grain values in between.
Basically, I&rsquo;d increase the input exponentially and then increase granularity from there.</p>

<p>(5) Performancce - Space complexity</p>

<p>Very similar to (4), I would explain the space complexity I expect out of my solution.
I would draw a simple graph of what it would probably look like.
I would then provide a set of sample points that I would take to see the space complexity.
Personally, I would mention that many languages like Java allow you to run at a reduced heap size like 4 MB so that you can hit <code>OutOfMemory</code> exceptions very quickly with reasonably sized inputs, if the complexity isn&rsquo;t managed properly.</p>
]]></content>
  </entry>
  
</feed>
