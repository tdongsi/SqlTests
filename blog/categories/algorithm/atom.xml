<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Personal Interview Notes]]></title>
  <link href="http://tdongsi.github.io/SqlTests/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/SqlTests/"/>
  <updated>2018-05-10T14:25:05-07:00</updated>
  <id>http://tdongsi.github.io/SqlTests/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Graph Data Structures]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2015/05/02/graph-data-structures/"/>
    <updated>2015-05-02T10:54:59-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2015/05/02/graph-data-structures</id>
    <content type="html"><![CDATA[<p>Summary of chapter 14 &ldquo;Graph Algorithms&rdquo; in &ldquo;Data Structures &amp; Algorithms in Python&rdquo; by GTG.</p>

<!--more-->


<h3>Vertices and Edges</h3>

<pre><code class="python Vertex">class Vertex:
    """Lightweight vertex structure for graph"""
    __slots__ = "_element"

    def __init__(self, x):
        self._element = x

    def element(self):
        return self._element

    def __hash__(self):
        return hash(id(self))

    def __str__(self):
        return "[Vertex: %s]" % self._element
</code></pre>

<pre><code class="python Edge">class Edge:
    """Lightweight edge structure for graph"""
    __slots__ = "_src", "_des", "_element"

    def __init__(self, u, v, x):
        self._src = u  # source
        self._des = v  # destination
        self._element = x

    def endpoints(self):
        return self._src, self._des

    def opposite(self, u):
        if u is self._src:
            return self._des
        elif u is self._des:
            return self._src
        else:
            raise ValueError("Unknown vertex")

    def element(self):
        return self._element

    def set_element(self, val):
        self._element = val
        pass

    def __hash__(self):
        return hash((self._src, self._des))

    def __str__(self):
        return "%s &gt;- %s -&gt; %s" % (self._src, self._element, self._des)
</code></pre>

<h3>Graph</h3>

<pre><code class="python Graph">class Graph:
    """Simple graph using an adjancency map"""

    def __init__(self, directed=False):
        self._outgoing = {}
        # Only create the second map for directed graph
        self._incoming = {} if directed else self._outgoing

    def is_directed(self):
        return self._outgoing is not self._incoming

    def vertex_count(self):
        """Return the number of vertices in the graph"""
        return len(self._outgoing)

    def vertices(self):
        """Return the iteration of all vertices"""
        return self._outgoing.keys()

    def edge_count(self):
        """Return the number of edges"""
        total = sum([len(self._outgoing[v]) for v in self.vertices()])
        return total if self.is_directed() else total//2

    def edges(self):
        """Return the iteration of all edges"""
        result = set()
        for secondary_map in self._outgoing.values():
            result.update(secondary_map.values())
        return result

    def get_edge(self, u, v):
        # TRICKY: self._outgoing[u][v] will raise KeyError instead of None if (u,v) not found
        return self._outgoing[u].get(v)

    def degree(self, v, outgoing=True):
        if outgoing:
            return len(self._outgoing[v])
        else:
            return len(self._incoming[v])

    def incident_edges(self, v, outgoing=True):
        """Return an *iteration* of incident edges"""
        adj = self._outgoing if outgoing else self._incoming
        for e in adj[v].values():
            yield e

    def insert_vertex(self, x=None):
        v = Vertex(x)
        self._outgoing[v] = {}
        if self.is_directed():
            self._incoming[v] = {}
        return v

    def insert_edge(self, u, v, x=None):
        e = Edge(u, v, x)
        self._outgoing[u][v] = e
        self._incoming[v][u] = e
        return e

    def delete_edge(self, u, v):
        del self._outgoing[u][v]
        del self._incoming[v][u]
        pass
</code></pre>

<h3>Modifications for Network Flows</h3>

<p>Note that for Network Flow problem, we must add <code>set_element</code> to Edge class and <code>delete_edge</code> to Graph class.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graph Data Algorithms]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2015/05/01/graph-algorithms/"/>
    <updated>2015-05-01T03:12:53-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2015/05/01/graph-algorithms</id>
    <content type="html"><![CDATA[<p>Summary of chapter 14 &ldquo;Graph Algorithms&rdquo; in &ldquo;Data Structures &amp; Algorithms in Python&rdquo; by GTG.</p>

<!--more-->


<h3>Graph traversals</h3>

<h4>BFS</h4>

<pre><code class="python Book version">def BFS(g:Graph, s:Vertex, discovered):
    """ BFS traversal of the undiscovered portion of Graph g starting at vertex s.

    :param g: give Graph
    :param s: starting Vertex
    :param discovered: Mapping each vertex to the edge used to discover it.
    :return:
    """
    level = [s]

    while len(level) &gt; 0:
        next_level = []
        for v in level:
            for e in g.incident_edges(v):
                u = e.opposite(v)
                if u not in discovered:
                    discovered[u] = e
                    next_level.append(u)

        level = next_level
</code></pre>

<h3>Transitive Closure</h3>

<p>Background: If the graph representation is adjacency list or adjacency map, we can answer the question of reachability for any u and v in <code>O(n+m)</code> (where <code>n</code> is the number of nodes, <code>m</code> is the number of edges).
However, if you have to answer <strong>many</strong> reachability queries (e.g., navigation application), it is better to construct a transitive closure for that graph.</p>

<p>A transitive closure <code>G'</code> is for a directed graph <code>G</code>: any u and v that are reachable, there is an edge (u, v) in <code>Gâ€™</code>.</p>

<p>In the classic adjacency list or adjacency map representation, transitive closure can be constructed in <code>O(n(n+m))</code> by repeating DFS at each vertex.
However, when the graph is dense (m -> n<sup>2</sup>), you is better off with Floyd-Warshall algorithm <code>O(n^3)</code> using <strong>adjacency matrix</strong> representation.
Floyd-Warshall requires get_edge and insert_edge to be done in <code>O(1)</code> time, which necessitates adjacency matrix requirements.</p>

<p>In theory, <code>O(n^3)</code> is not better than repeated DFS traversals <code>O(n(n+m))</code>.
However, in practice, Floyd-Warshall is faster and easier to implement because there are fewer low-level operations.
However, when the graph is sparse, repeated DFS traversal approach is better in time and space complexity.</p>

<pre><code class="python Floyd-Warshall implementation">def floyd_warshall(g:Graph) -&gt; Graph:
    """ Return a new graph that is the transite closure of g.

    :param g: input graph
    :return: the transitive closure of g.
    """
    closure = deepcopy(g)
    verts = list(closure.vertices())
    n = len(verts)

    for k in range(n):
        for i in range(n):
            # verify that edge(i, k) exists in the partial closure
            if i != k and closure.get_edge(verts[i], verts[k]) is not None:
                for j in range(n):
                    # verify that edge(k, j) exists in the partial closure
                    if i != j != k and closure.get_edge(verts[k], verts[j]) is not None:
                        if closure.get_edge(verts[i], verts[j]) is None:
                            # if (i, j) not yet included, add it to the closure
                            closure.insert_edge(verts[i], verts[j])

    return closure
</code></pre>

<h3>DAG and topological sorting.</h3>

<p>A directed graph may have more than one topological ordering.</p>

<blockquote><p><strong>Proposition</strong>: A directed graph has a topological sorting if and only if it is acyclic.</p></blockquote>

<pre><code class="python Topological sorting">def topological_sort(g: Graph) -&gt; list:
    """ Return a list of vertices of DAG in topological order

    :param g: a directed acyclic graph (DAG)
    :return: list of topological sort
    """
    topo = []
    ready = []
    incount = {}

    for u in g.vertices():
        incount[u] = g.degree(u, False)
        if incount[u] == 0:
            # u is free of constraints
            ready.append(u)

    while len(ready) &gt; 0:
        u = ready.pop()
        topo.append(u)

        for e in g.incident_edges(u):
            v = e.opposite(u)
            incount[v] -= 1
            if incount[v] == 0:
                ready.append(v)

    return topo
</code></pre>

<h3>Shortest Paths</h3>

<p>We have a few choices for implementing &ldquo;adaptable priority queue with location-aware entries&rdquo; (at least <code>remove_min</code> required) in Dijkstra&rsquo;s algorithm:</p>

<ul>
<li>Unsorted sequence implementation -> <code>O(n^2 +m)</code> runtime.</li>
<li>A heap implementation -> <code>O( (n+m)log(n) )</code> runtime.</li>
<li>Fibonacci heap implementation -> <code>O(m +nlog(n))</code> runtime.</li>
</ul>


<p>The &ldquo;heap implementation&rdquo; is &ldquo;AdaptableHeapPriorityQueue&rdquo; class from the chapter 9 of the same textbook.
The &ldquo;Unsorted sequence implementation&rdquo; is implemented as follows, using the same signature of the above class for later compatibility:</p>

<pre><code class="python Simple Adaptable Priority Queue implementation">class AdaptableUnsortedPriorityQueue():
    """ Mocking AdaptableHeapPriorityQueue.
    loc =&gt; key in internal map
    key, val =&gt; value in internal map
    """

    def __init__(self):
        self._map = {}

    def add(self, key, value):
        """Add a key-value pair."""
        self._map[value] = (key, value)
        return value

    def update(self, loc, newkey, newval):
        """Update the key and value for the entry"""
        self._map[loc] = (newkey, newval)

    def is_empty(self):
        return (len(self._map) == 0)

    def remove_min(self):

        min_key = float('inf')
        min_loc = None
        min_return = None

        for loc, val in self._map.items():
            if val[0] &lt; min_key:
                min_key = val[0]
                min_loc = loc
                min_return = val

        del self._map[min_loc]
        return min_return
</code></pre>

<p>Python implementation of Dijkstra&rsquo;s algorithm is shown below.
Dijkstra&rsquo;s algorithm is analogous to a weighted BFS traversal.
A few assumptions must be true in this implementation:</p>

<ul>
<li>Theoretical requirement: All the weights are nonnegative.</li>
<li><code>e.element()</code> returns the weight of the edge.</li>
</ul>


<pre><code class="python Dijkstra's algorithm">def shortest_path_lengths(g:Graph, s:Vertex):
    """ Compute shortest-path distances from src to reachable vertices of g.
    Dijkstra's Algorithm for finding shortest paths.

    :param g: directed or undirected Graph. e.element() must return non-negative weight
    :param s: Starting vertex
    :return: dictionary mapping each reachable vertex to its distance from s.
    """

    d = {}      # d[v] is upper bound from s to v
    cloud = {}  # map reachable v to its d[v] value
    pq = AdaptableUnsortedPriorityQueue()   # vertex v will have key d[v]
    pqlocator = {}      # map from vertex to its pq locator

    for v in g.vertices():
        if v is s:
            d[v] = 0
        else:
            d[v] = float('inf')

        pqlocator[v] = pq.add(d[v], v)

    while not pq.is_empty():
        key, u = pq.remove_min()
        cloud[u] = key

        for e in g.incident_edges(u):
            v = e.opposite(u)
            if v not in cloud:
                wgt = e.element()
                if d[u] + wgt &lt; d[v]:
                    d[v] = d[u] + wgt
                    pq.update(pqlocator[v], d[v], v)

    return cloud
</code></pre>

<p>Then, based on the returned computed shortest-path distances, we can compute <strong>shortest-path tree</strong>.
We use the same data structure that represents <strong>DFS tree</strong> and <strong>BFS tree</strong>: a map that maps a vertex to its discovery edge (edge connecting to its parent).
Because of using the same data structure, you can reuse the method <code>construct_path</code> to compute the path from one vertex to another.</p>

<pre><code class="python Compute shortest path tree">def shortest_path_tree(g: Graph, s: Vertex, d:dict) -&gt; dict:
    """ Reconstruct shortest-path tree rooted at vertex s, given the distance map d.
    Return tree as a map from vertex v -&gt; discovery edge.

    :param g: Given graph, directed or undirected.
    :param s: starting vertex.
    :param d: distance map, created from Dijkstra's algorithm.
    :return:
    """
    tree = {}

    for v in d:
        if v is not s:
            for e in g.incident_edges(v, False):
                u = e.opposite(v)
                wgt = e.element()
                if d[v] == d[u] + wgt:
                    tree[v] = e

    return tree
</code></pre>

<p>Example usage:</p>

<pre><code class="python Example usage">def test_dijkstra_algorithm(self):
    g = ExampleGraphs.airport_graph()

    vertex_map = {v.element() : v for v in g.vertices()}
    starting_vertex = vertex_map["JFK"]

    cloud = shortest_path_lengths(g, starting_vertex)

    for k, v in cloud.items():
        print("%s: %s"% (k,v))

    sp_tree = shortest_path_tree(g, starting_vertex, cloud)
    path = construct_path(vertex_map["JFK"], vertex_map["LAX"], sp_tree)

    print("Shortest path from JFK to LAX")
    for ap in path:
        print(str(ap))
</code></pre>

<pre><code class="plain Example output">Shortest path from JFK to LAX
[Vertex: JFK]
[Vertex: ORD]
[Vertex: DFW]
[Vertex: LAX]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Flow: Basics]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2015/04/11/network-flow-basics/"/>
    <updated>2015-04-11T18:51:41-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2015/04/11/network-flow-basics</id>
    <content type="html"><![CDATA[<p>Summary of chapter 7 &ldquo;Network Flows&rdquo; in &ldquo;Algorithm Design&rdquo; by Kleinberg &amp; Tardos.</p>

<!--more-->


<h3>Network Flow Basics</h3>

<p>Augmenting Path</p>

<pre><code class="plain Augment pseudocode">TODO
</code></pre>

<p>Ford-Fulkerson method</p>

<pre><code class="plain Ford-Fulkerson pseudocode">TODO
</code></pre>

<p>If all capacities in the flow network G are integers, then the Ford-Fulkerson method runs in O(mC) time.</p>

<h3>Capacity-Scaling Algorithm</h3>

<p>Algorithm</p>

<p>Runtime</p>

<h3>Edmonds-Karp Algorithm</h3>

<pre><code class="python Edmonds-Karp variant of Ford-Fulkerson method">def edmonds_karp(g: Graph, source: Vertex, sink: Vertex):
    """ Edmonds-Karp implementation of Ford-Fulkerson method.
    If you have an original network flow, you should create a deep copy of it AND retrieve the right source/sink vertcies.

    :param g: residual graph
    :param source: source Vertex
    :param sink: sink Vertex
    :return: maximum flow
    """

    def BFS_augment_path(g, s, t):
        """ Find BFS path from s to t in network flow graph.

        :param s: source
        :param t: sink
        :return: list of edges from s to t. Empty if there is no path.
        """
        discovered = BFS_iter(g, s)
        vertices = construct_path(s, t, discovered)
        edges = []

        if vertices:
            for i in range(len(vertices)-1):
                edges.append(g.get_edge(vertices[i], vertices[i+1]))

        return edges

    max_flow = 0
    path = BFS_augment_path(g, source, sink)

    while path:

        path_flow = min([e.element() for e in path])
        max_flow += path_flow

        for e in path:
            u, v = e.endpoints()

            # Update forward residual edge
            cur = e.element()
            if cur - path_flow == 0:
                g.delete_edge(u, v)
            else:
                e.set_element(cur - path_flow)

            # Update backward residual edge
            if g.get_edge(v, u) is None:
                g.insert_edge(v, u, path_flow)
            else:
                reverse_edge = g.get_edge(v, u)
                cur = reverse_edge.element()
                reverse_edge.set_element(cur + path_flow)

        path = BFS_augment_path(g, source, sink)

    return max_flow
</code></pre>

<h3>Blocking-Flow Algorithm</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Book: GTG: Text Processing]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2013/04/23/book-gtg-text-processing/"/>
    <updated>2013-04-23T16:34:23-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2013/04/23/book-gtg-text-processing</id>
    <content type="html"><![CDATA[<p>Summary of chapter 14 &ldquo;Graph Algorithms&rdquo; in &ldquo;Data Structures &amp; Algorithms in Python&rdquo; by GTG.</p>

<!--more-->


<h3>Pattern-Matching Algorithms</h3>

<p>For the following algorithms, <code>m</code> is the length of the pattern (substring) and <code>n</code> is the length of the larger text.</p>

<h4>Brute-force algorithm</h4>

<p>The brute force running time is <code>O(mn)</code>.</p>

<pre><code class="python Brute Force">def find_brute(text:str, subs: str):
    """ Pattern matching with brute force.
    Return the lowest index of text T at which substring P begins (or else -1).

    :param text: text T
    :param subs: substring P
    :return: lowest index of T
    """
    if not text or not subs:
        return -1

    n, m = len(text), len(subs)

    for i in range(n - m + 1):
        k = 0
        while k &lt; m and text[i+k] == subs[k]:
            k += 1
        if k == m:
            return i

    return -1
</code></pre>

<h4>Boyer-Moore algorithm</h4>

<pre><code class="python Boyer-Moore algorihtm">def find_boyer_moore(text:str, subs:str):
    """ Pattern matching with Boyer-Moore algorithm.
    Return the lowest index of text T at which substring P begins (or else -1).

    :param text: text T
    :param subs: substring P
    :return: lowest index of T
    """
    if not text or not subs:
        return -1

    n, m = len(text), len(subs)

    last = {}
    for k in range(m):
        last[subs[k]] = k

    # align end of pattern at index m-1 of text
    i = m-1  # index into 'text'
    k = m-1  # index into 'subs'
    while i &lt; n:
        if text[i] == subs[k]:  # a matching character
            if k == 0:
                return i  # pattern begins at index i of text
            else:
                i -= 1  # examine previous characters in both T &amp; P
                k -= 1
        else:
            j = last.get(text[i], -1)
            # Sanity check:
            # 1) text[i] not in last -&gt; i += m
            # 2) text[i] in last -&gt; i += m - (j+1)
            i += m - min(k, j+1)
            k = m -1  # restart at end of pattern

    return -1
</code></pre>

<h4>Knuth-Morris-Pratt algorithm.</h4>

<p>The KMP running time is <code>O(m+n)</code>.</p>

<pre><code class="Python KMP algorithm">def compute_kmp_fail(pattern: str):
    """ Utility function that computes and returns KMP failure function.

    :param pattern: the pattern
    :return: list as lookup table
    """
    m = len(pattern)
    fail = [0] * m
    j = 1
    k = 0
    while j &lt; m:
        if pattern[j] == pattern[k]:  # k+1 characters match thus far
            fail[j] = k+1
            j += 1
            k += 1
        elif k &gt; 0:
            k = fail[k-1]
        else:  # no match found starting a j
            j += 1
    return fail


def find_kmp(text: str, subs: str):
    """ Pattern matching with Knuth-Morris-Pratt algorithm.
    Return the lowest index of text T at which substring P begins (or else -1).

    :param text: text T
    :param subs: substring P
    :return: lowest index of T
    """
    if not text or not subs:
        return -1

    n, m = len(text), len(subs)

    fail = compute_kmp_fail(subs)

    j = 0
    k = 0
    while j &lt; n:
        if text[j] == subs[k]:
            if k == m-1:
                return j - m + 1
            j += 1
            k += 1
        elif k &gt; 0:
            k = fail[k-1]
        else:
            j += 1

    return -1
</code></pre>

<h3>DP and Longest Common Subsequence</h3>

<p>See <a href="TODO">here</a>.</p>

<h3>Huffman coding method.</h3>

<p>SKIP.</p>

<h3>Tries</h3>

<p>The idea of tries comes from the fact that text search can be sped up with preprocessing the pattern such as Boyer-More and KMP algorithms.
Such approach is suitable for applications where a series of queries is performed on a fixed text, so that the initial cost of preprocessing is compensated by a speed up in each subsequent query.</p>

<p>A trie is for storing strings in order to support fast pattern matching.
The main application for tries is for information retrieval.
The primary query operations are pattern matching and prefix matching.</p>

<h4>Standard trie</h4>

<p>One key assumption in trie is that no string in S is a prefix of another string.
This ensures that each string in S is uniquely associated with a leaf of T.
We can satisfy this assumption by adding a special termination character (conventionally <code>$</code>) that is not in the alphabet at the end of each string.</p>

<p>Standard operations:</p>

<ul>
<li>Seach for a string of length <code>m</code>: <code>O(m)</code>.

<ul>
<li>Rationale: We visit at most <code>m+1</code> nodes in T and we spend <code>O(1)</code> at each node if we have secondary hash table/lookup table at each node for search.</li>
<li>Only works for exact word matching or prefix matching. Arbitrary substring search does not work.</li>
</ul>
</li>
<li>Construction of trie: <code>O(n)</code>.

<ul>
<li><code>n</code> is the total length of the strings in S.</li>
</ul>
</li>
</ul>


<h4>Compressed trie</h4>

<p>Compressed trie is also known as Patricia trie for historical reasons.
Each internal node of compressed trie has at least two children.
It enforces this rule by compressing chains of single-child nodes into individual edges.
Nodes in compressed trie are labeled with strings instead of single characters as in standard trie.
The advantange of compressed trie is that the number of nodes of the compressed trie is proportional to number of strings, instead of its total length.</p>

<p>The real space savings come when it is used as auxiliary index structure over a collection of strings already stored in some other primary structure.
Then, we can use numeric indexes in trie instead of storing actual characters.
Searching in a compressed trie is not actually faster than a standard trie.</p>

<h4>Suffix Trie</h4>

<p>More info at <a href="https://www.youtube.com/watch?v=N70NPX6xgsA">here</a>.</p>

<p>A suffix trie is a compressed trie containing all the suffixes of the given text X of size <code>n</code> from an alphabet of size <code>d</code>.
Note that trivially storing all the suffixes of an X would take <code>O(n^2)</code> space.
However, the compact representation of a compressed trie is proportional to number of strings and uses <code>O(n)</code> space instead.
It can be constructed with a specialized algorithm in <code>O(dn)</code> time (not discussed in book).
The standard trie construction would take <code>O(d*n^2)</code> time.</p>

<p>Standard operations:</p>

<ul>
<li>Seach for a pattern/prefix of length <code>m</code>: <code>O(dm)</code>.</li>
</ul>


<p>Applications:</p>

<ul>
<li>Pattern/Prefix searching</li>
<li>Exact string matching</li>
<li>Finding the longest repeated substring</li>
<li>Finding the longest palindrome in a string: Manacher&rsquo;s algorithm.</li>
<li>Lowest common ancestors</li>
<li>Finding the longest commont substring</li>
</ul>


<h4>Search Engine Indexing</h4>

<p>The core information stored by a search engine is a dictionary, called an <strong>inverted index</strong> or <strong>inverted file</strong>, storing the following key-value pairs:</p>

<ul>
<li>keys: words (index terms)</li>
<li>values: occurrence lists: collection of pages containing the corresponding key word.</li>
</ul>


<p>We can implement the inverted file with a data structure consisting of the following:</p>

<ul>
<li>A compressed trie for the set of keys (index terms), where each leaf stores the index of the occurence list.</li>
<li>An array storing the occurrence lists of the terms.</li>
</ul>


<p>The compressed trie can be fit into the memory while the much larger array for the occurrence lists can be stored on disk.</p>

<p>A query for a single keyword is similar to a word-matching query.
Namely, we find the keyword in the trie and we return the associated occurrence list.
When multiple words are given and the desired output are the pages containing all the given keywords, we retrieve all the occurrence lists and find their intersection.
Note that for a real search engine, additional service must be provided such as ranking the pages returned by relevance.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Glassdoor: Algorithm Question Bank]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2012/02/29/question-bank/"/>
    <updated>2012-02-29T22:31:29-08:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2012/02/29/question-bank</id>
    <content type="html"><![CDATA[<p>These questions are gathered from Glassdoor.</p>

<!--more-->


<h3>Questions</h3>

<h4>LinkedIn</h4>

<ol>
<li>Serialize binary tree.</li>
<li>Count the number of occurrences of a given element in a sorted array.</li>
<li>Modify binary search to find the index of first/last occurrence of x in the array. Two binary searches.</li>
<li>Design a program to take a string and store, each character, into an array. The array should return a count of each character when called. [The interviewer was clearly trying to blur the lines between a simple program and a MapReduce]</li>
<li>Senior Test Engineer: A user logs in to a website with proper credentials and the user is taken to a blank page. How would you troubleshoot that?</li>
<li>Senior Test Engineer: Create a stack with the usual push() &amp; pop(), but with an additional function getMiddle() that returns the middle element of the stack in constant time.</li>
<li>Senior Test Engineer: Search a sorted array for the first element larger than k.</li>
<li>You have a potentially very-large set of documents, which are potentially very-large, and contain text. For searching these documents, they&rsquo;ve been pre-processed into a (very-large) table mapping words to the set of documents that contain each word. E.g. (word) : (documents (referenced by ID) containing that word) Apple: 1, 4, 5, 6, 32 Banana: 5, 6, 7, 9, 32 Cantaloupe: 1, 2, 6 &hellip; Clients will pass in a set &hellip;</li>
<li>Given a nested list of integers, return the sum of all integers in the list weighted by their depth For example, given the list <code>[[1,1],2,[1,1]]</code> the function should return 10 (four 1 at depth 2, one 2 at depth 1). Answer: Recursion or Use a stack while iterating through the input string.</li>
<li>Create an isNumber(string) function. Handle signed / unsigned, floating point, any number of digits, etc. Probably commas, and currency signs, or whatever. It was open ended and governed by whatever unit tests he wanted you to make it work against.</li>
<li>Find out at least one 3 elements array in a given integer array. The 3 elements have to be able to form a triangle.</li>
<li>Write a program to replace 0s with 5 in a given number. Eg: 1208 -> 1258, 120096045 -> 125596545</li>
<li>Write a function to find the power of a<sup>b</sup></li>
<li>Find the minimum distance between 2 words in a dictionary</li>
<li>Evaluate a post-fix expression</li>
<li>Given an array of numbers , replace each number with the product of all the numbers divided by the number at that index without using the division operator.</li>
<li>Write a function that, given a list of integers (both positive and negative) returns the sum of the contiguous subsequence with maximum sum. Thus, given the sequence (1, 2, -4, 1, 3, -2, 3, -1) it should return 5.</li>
<li>Write a function that would find the largest palindrome (phone interview).</li>
<li>Write a Binary Search Tree class with isBST() method that will validate if the tree is a BST (onsite).</li>
</ol>


<h4>Google</h4>

<ol>
<li>Given a list of integers and another integer. Write a program that returns the posible combinations of the list which added, match the integer, numbers can repeat itself.</li>
<li>Write a function to check if a string is palindrome? Write a function to return the largest Palindrome as possible in a given string. Hint: O(N)</li>
<li>Check if Sudoku is valid</li>
<li>You have unsorted array. You must design algorithm to create array where every even value is greater than it&rsquo;s odd neighbors. So if a(i) is value at index i (=0,1,2&hellip;n), the result must hold that: a1 &lt; a2 > a3 &lt; a4 > a5&hellip;</li>
<li>Merge K sorted lists.</li>
<li>System design: design a system that given a point on earth will return the highest building in 100m radios. The question was developing. Start by assuming everything in memory. Then assume not everything fits, then use several machines, then consider what happens when one is down. The purpose is to answer as quickly as possible but you have preprocessing time.</li>
<li>0-1 Knapsack problem. NP-complete/NP-hard.</li>
<li>Design a load balancer for web servers.</li>
</ol>


<h4>Salesforce</h4>

<ol>
<li>Q: Explain Encupsulation</li>
<li>Q: Inheritance vs composition</li>
<li>Q: What&rsquo;s the difference between tree and HashTable.</li>
<li>Also asks me to create classes for file system API.</li>
<li>How to ensure locking in Singleton class</li>
<li>Do a producer consumer problem</li>
<li>Reach 2D Pt x to Pt y in spiral form -> right -> down -> left -> up moving 1 point at a time.</li>
<li>Find all words which start from particular letter (case insensitive)</li>
<li>The number of paths in a m x n grid to a given cell?</li>
<li>Given an ordered large array of integers, find all pairs of numbers that add up to a particular given sum.</li>
<li>Given a regular English dictionary, and a word to start with (e.g. &ldquo;head&rdquo;), you can only change one letter a time, but every change has to be a word in the dictionary (e.g. head -> heal) What is the quickest way to an end word (e.g. &ldquo;tail&rdquo;)?</li>
<li>How to efficiently merge two sorted binary trees?</li>
<li>Why its said a good practice to override() hashcode() of an object when you override equals()?</li>
<li>Given an array of integers, return top K elements from it.</li>
<li>Given 2 unsorted integer arrays, get the intersection of the 2.</li>
<li>question about finding out the character that occurs most in a given string.</li>
<li>What is the JRE and what does it have to do with .jar files?</li>
<li>Explain / implement a hash table.</li>
<li>Given 3 tasks from 3 bosses, how would u handle the priority if you could only finish one of them.</li>
<li>Three major difference between C++ and Java.</li>
<li>Given a constant input stream of integers design a way to, at any point, return the current median of that stream.</li>
<li>Get unique items from an array.</li>
<li>given an binary search tree (that is, an ordered tree), how would you find the element of the tree at a particular &ldquo;index&rdquo;, where index is defined as the position in the tree&rsquo;s ordering.</li>
<li>Fastest way to find the middle node in a linked list</li>
<li>Eliminate the duplicate elements from a given linked list.</li>
<li>Union find algorithm.</li>
<li>clockwise print out a M*N matrix. Solution: recursive</li>
<li>Explain way to optimize SQL.

<ol>
<li><a href="http://www.vertabelo.com/blog/technical-articles/5-tips-to-optimize-your-sql-queries">http://www.vertabelo.com/blog/technical-articles/5-tips-to-optimize-your-sql-queries</a></li>
</ol>
</li>
<li>Counting the frequency of words in a list.. hashtable with word keys and word count values..</li>
<li>Find Pairs with least absolute difference in an given unsorted array.

<ol>
<li>NOTE: if the numbers are in a given range</li>
</ol>
</li>
<li>Explain difference in Heap and Stack memory for JVM.

<ol>
<li><a href="http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html">http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html</a></li>
<li><a href="https://www.youtube.com/watch?v=450maTzSIvA">https://www.youtube.com/watch?v=450maTzSIvA</a></li>
</ol>
</li>
<li>Image url parser from an html page and its child pages.</li>
<li>Implement Que using 2 stacks. write test cases for it.</li>
<li>Write thread safe singleton class</li>
<li>what are joins in database, some scenario where u used it</li>
<li>Given two sorted arrays, find the intersection of the two arrays.</li>
<li>Find duplicate from a very large list (trillion) of immutable integers in known range. O(N) and O(1) additional space solution.</li>
</ol>


<p>Set B</p>

<ol>
<li>JS - what is eval()</li>
<li>JS - what is the diffenrence between == and ===</li>
<li>How hashmaps work - hashCode and equals operators</li>
<li>Principles of OO - encapsulation, inheritance</li>
<li>What is synchronized?</li>
<li>Big O of data searching on different data structures - array , linked list, hashtable</li>
<li>Java difference of a hashtable and hashmap</li>
<li>Something that you are proud of - code and other - industry related</li>
<li>Describe a development process - engaging client - requirements - etc</li>
<li>Favorite java classes</li>
<li>What does AJAX stands for?</li>
<li>what type of response can you get from and AJAX call - string or XML</li>
</ol>


<p>Set C:</p>

<ol>
<li>Describe Singleton in a Real Life Example , like if you want to explain concept of singleton pattern to your grandmother, who don&rsquo;t know the computer at all. what would be your approach.</li>
<li>How would you design a Chat Session (gtalk) ?</li>
<li>write program to calculate power(x,n) in log(n) time</li>
<li>Find intersection node of two linked lists.</li>
<li>Merge two sorted linked lists into one without extra space.</li>
<li>Given an array, which contains integers in the range of 1 to n. one number is missing from it and one number is repeated in array. for ex &ndash; array is {1,2,3,4,4,6,7,8,9} , range given is 1- n(n=9).
determine which number is missing and which is repeated in array.</li>
<li>given char array = {a,a,a,a,b,b,b,c,c,d,d,,e,,f,f}
output should be &ndash; {a,4,b,3,c,2,d,2,e,f,2}, i.e. occurrences of every element followed by character, without using other array.</li>
</ol>


<h4>Others</h4>

<ol>
<li>Implement a FIFO queue from 2 FILO stacks</li>
<li>Calculate Fibonacci-like sequence: f(n) = f(n-1) + â€¦ + f(n-k) where f(i) = 0 if i &lt; 0 and f(0) = 1. Your algorithm should avoid shifting lots of number.</li>
<li>Given 2 sorted arrays, how do I get the median of the combined 2 arrays.</li>
<li>Given a sorted array and a number k, find 2 number a, b such that a + b = k. Your algorithm should be O(n). If the array is unsorted, can you still do in O(n)?</li>
<li>In-order traversal? In-order traversal without recursion?</li>
</ol>


<h4>Dynamic programming problems</h4>

<p>At least one dynamic programming problem will be asked during on-site interview.</p>

<ol>
<li>Given a number n, find a set such that

<ul>
<li>Sum of all the elements should result into n.</li>
<li>Multiplication of all the elements should be greater than any other similar set (whose elements result n when summed up).</li>
</ul>
</li>
</ol>


<h4>Concurrency</h4>

<ol>
<li>How to write a thread-safe or reentrant function. What is the difference between a reentrant function and thread-safe function?

<ul>
<li>Reentrant and thread-safe is actually two separate concepts.</li>
</ul>
</li>
</ol>


<h4>Object oriented programming</h4>

<ol>
<li>What is OOP? What is abstraction, encapsulation, inheritance, polymorphism?</li>
</ol>


<h3>Answers</h3>

<h4>Others</h4>

<p>(3) Given 2 sorted arrays, how do I get the median of the combined 2 arrays?</p>

<p>The basic idea is that if you are given two arrays A and B and know the length of each, you can check whether an element A[i] is the median in constant time. Suppose that the median is A[i].
Since the array is sorted, it is greater than exactly i âˆ’ 1 values in array A.
Then if it is the median, it is also greater than exactly j = ceil(n/2) âˆ’ (i âˆ’ 1) elements in B.
It requires constant time to check if B[j] &lt;= A[i] &lt;= B[j + 1].
If A[i] is not the median, then depending on whether A[i] is greater or less than B[j] and B[j + 1], you know that A[i] is either greater than or less than the median.
Thus you can binary search for A[i] in O(lg n) worst-case time.</p>

<p>(4) Given a sorted array and a number k, find 2 number a, b such that a + b = k.</p>

<p>Time O(n) and O(n) for sorted and unsorted array.
a) If the array is sorted, use two pointers at the two ends of the aray.
b) If the array is not sorted, create a hash table with keys as (k-a[i]). Then look up for each a[i] in the table. Table insertion and table look-up is O(1).</p>

<h4>OOP</h4>

<p>(1) What is OOP?</p>

<ul>
<li>OOP: a programming paradigm that uses objects to design computer applications. Here, objects are special data structures that consist of data fields and methods interacting with those data fields. OOP techniques includes the followings: data abstraction, encapsulation, inheritance, polymorphism, messaging.</li>
<li>Data abstraction: means that we interact with data in objects using its abstract interface. For example, we access private data of an object using its public methods. It is a mechanism to restrict the access to some of data structure&rsquo;s component, usually to separate the implementation details of the data structure.</li>
<li>Encapsulation: in simple definition, the implementation details of a program is separated from its representation. It means that we separate &ldquo;what an object can do&rdquo; and &ldquo;how the object do it&rdquo;.</li>
<li>Inheritance: is the ability of a class to expand as a subclass, so that the code can be reused.</li>
<li>Polymorphism: is the ability of a class can be considered as different forms.</li>
<li>Message passing: in OOP, a message is the single means to pass control to an object. Alan Kay has argued that message passing is more important than objects in OOP, and that objects themselves are often over-emphasized.</li>
</ul>

]]></content>
  </entry>
  
</feed>
