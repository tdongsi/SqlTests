<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Database | Personal Interview Notes]]></title>
  <link href="http://tdongsi.github.io/SqlTests/blog/categories/database/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/SqlTests/"/>
  <updated>2017-12-21T19:48:08-08:00</updated>
  <id>http://tdongsi.github.io/SqlTests/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tutorial: Dashboard for Business Analytics]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2016/08/05/tutorial-dashboard-for-business-analytics/"/>
    <updated>2016-08-05T15:40:35-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2016/08/05/tutorial-dashboard-for-business-analytics</id>
    <content type="html"><![CDATA[<p>Summary of &ldquo;Business Dashboard Fundamentals&rdquo; on Pluralsight.</p>

<!--more-->


<h3>General guidelines for dashboard</h3>

<p>Ppl looks for different things in data. You have to find out what answers users look for in dashboard.</p>

<ul>
<li>Trend: bar, graph</li>
<li>Aggregation: Average, Sum, Max, Min.</li>
</ul>


<p>Above all else, show data.
Trying to improve data-pixel ratio: data pixels/non-data pixels.
How to enhance data-pixel ratio:</p>

<ul>
<li>Granularity: depends on the question you want to answer

<ul>
<li>monthly if you want to know monthly sales, daily if you want to know what happens last Tuesday.</li>
<li>category or sub-category: you can have category with drill down function.</li>
</ul>
</li>
<li>Annotation: similar to Granularity. Minimize it to enough to answer the question.</li>
</ul>


<p>Tricks &amp; Tips:</p>

<ul>
<li>Plots (over Bars): plot show the trends for different components over time.</li>
<li>Sizing Bars: Preserve True Portions: starting Y from 0.

<ul>
<li>Sizing Bars: shows proportions, relative progression.</li>
</ul>
</li>
<li>Scatter Plots: show clusters, outliers.</li>
<li>Radio displays: usually a bad idea. Waste of space, hard to discern between slices.</li>
</ul>


<h3>Module 2: Common Charts</h3>

<p>Basic data Presentation Methods - Chart Types</p>

<ul>
<li>Geo-Spatial - Maps: anything related to geographic distribution, i.e., when geography matters. e.g. real estates, oil industry.</li>
<li>Correlation - Scatter Plots: two measurements (e.g., sales to profit).</li>
<li>Hierarchical - Drill down Tree: data is hierarchical: Category -> Subcateogries.</li>
<li>Categorical - Bar Charts: comparing categories (sales by region)</li>
<li>Time Series - Line Charts: progression over time. (sales by month)

<ul>
<li>Avoid: Stacked Area Charts. If you have more than two lines, Area Charts do not give any information except for the bottom and the total.</li>
</ul>
</li>
<li>Distribution - Histograms: Trying to answer what is “normal”. e.g., home prices, salaries.</li>
</ul>


<p>Others</p>

<ul>
<li>Box plot: distribution, percentiles, median in 1 chart.</li>
<li>Bullet graph: actuals to target. Invented by Stephen Few.

<ul>
<li>Dark bar is actual, reference line is target. Color code bands are average, good, bad target range.</li>
<li><a href="https://en.wikipedia.org/wiki/Bullet_graph">https://en.wikipedia.org/wiki/Bullet_graph</a></li>
</ul>
</li>
<li>Sparkline: Multiple line charts. Best used for monitoring dashboard.</li>
<li>Heat map: Large combinations of dimensions. Color is everything here.</li>
</ul>


<p>Charts to avoid</p>

<ul>
<li>Pie charts: angles make it hard to compare. Usually decorative, not informative. Space is wasted.</li>
<li>Polar charts</li>
<li>Stacked area charts:

<ul>
<li>Only tell the story of the bottom line and the total. Anything in between, you can’t really tell if they are growing or not.</li>
<li>Misleading/Confusing: is the top the total or another category?</li>
</ul>
</li>
</ul>


<h3>Module 3: Dashboard planning</h3>

<p>Steps:</p>

<ul>
<li>User Request</li>
<li>Prioritization</li>
<li>Planning</li>
<li>Design</li>
<li>Development</li>
<li>Delivery to User</li>
</ul>


<h3>Module 4: Dashboard design</h3>

<p>Audience is King. Know your audience.</p>

<ul>
<li>Who is using it?</li>
<li>Are they technical or prefer dumbed down answers? Are they intimate with data?</li>
<li>What is primary objective? What questions that they try to answer? What questions this dashboard MUST answer?</li>
<li>What impact of the answer? How will they use metrics? (Role, what decisions they make)</li>
<li>When will the dashboard is used? (Weekly? Daily?) Dashboard is exploratory or explanatory?</li>
<li>What level of confidence in data sources?</li>
</ul>


<p>Dashboard layout: F layout is the most natural for web/desktop viewing.</p>

<h3>Module 5 &amp; 6: Tableau</h3>

<p>Connecting to Data:
You can connect to Excel, text file (csv or tab), or HP Vertica.
You can specify data import like Excel or using Custom SQL.
After importing, Tableau may import all data into its own internal data engine (with compression, data reorganization easier for analytics).
It also divides data into dimensions and measures.
Dimensions are further categorized into: geographic (e.g., region, postal code), number, text, date (e.g., calendar, order_date).
Facts are usually numbers but it can be other categories: e.g., geographic for latitude/longitude measures.</p>

<p>Visualizing data:
Tableau has “Show Me” button that gives suggestions for different combinations of dimensions and fact data.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tutorial: Dimensional Modelling]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2016/08/04/tutorial-dimensional-modelling/"/>
    <updated>2016-08-04T15:38:20-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2016/08/04/tutorial-dimensional-modelling</id>
    <content type="html"><![CDATA[<p>From Kimball group reader.</p>

<!--more-->


<h3>Dimensional Modeling for Data Warehouse</h3>

<h4>Item 1.5: Design</h4>

<p>Design items:
You need to do data profiling to keep data processed to min. One way to profile data changes is to use CDC column.
Check CDC columns: e.g. <code>last_update_ts</code>. If CDC columns are not available, work with production system DBA to add one.
Otherwise, check application log file/Message traffic.</p>

<p>Divide data into dimension and fact tables: 90% of the time the division is obvious.</p>

<ul>
<li>Dimensions: static entities in the environment

<ul>
<li>Text descriptions are obvious data going into dimension</li>
</ul>
</li>
<li>Facts: numeric observations/measurements.

<ul>
<li>Unpredictable, numeric numbers are the usual suspects.</li>
</ul>
</li>
</ul>


<p>Grain of fact table = a measurement in physical, real-world.</p>

<p>Design steps:</p>

<ul>
<li>Determine the single physical event you want to record -> fact table. Other details will follow in dimension tables.

<ul>
<li>What event is a single row in fact table representing? E.g. for fact_sale_event, the grain is literally the beep of the scanner.</li>
</ul>
</li>
<li>Strive to make facts additive.

<ul>
<li>E.g.: Sale event can go into fact table as (price, unit), but the information (sale amount, unit) contains the same information but better since sale amount (aka extended price) = price * unit.</li>
</ul>
</li>
<li>Some data can be in both. The goal is ease of use, not methodology correctness.

<ul>
<li>E.g.: Coverage amount of insurance policies can be in both dim_coverage and fact_sale_event.</li>
</ul>
</li>
</ul>


<h4>Item 1.6</h4>

<p>Bus matrix to communicate/manage dimension tables.</p>

<p>TODO: Table of bus matrix</p>

<h4>Item 1.8 Slow Changing Dimensions</h4>

<ul>
<li>Type 0: Constant. Ignore changes.</li>
<li>Type 1: Simple overwrite (best used for error correction).</li>
<li>Type 2: Create another row and save history.

<ul>
<li>The standard implementation is: surrogate key (PK), durable ID, … attributes …, effective_start_date, effective_end_date, change_reason, current_flag.</li>
</ul>
</li>
<li>Type 3: Create another column for alternate info.</li>
</ul>


<h4>Item 1.10 Fact tables</h4>

<p>Data warehouse is built on fact tables expressed at the lowest possible grain.
Higher grain aggregated tables such as category sales by district.</p>

<p>Three kinds of fact tables:</p>

<ol>
<li>Transaction Grain: corresponds to a measurement taken at a single instant.

<ol>
<li>Unpredictably sparse or dense.</li>
<li>Can be enormous. Cannot guarantee all possible foreign keys represented.</li>
<li>E.g.: fact_qbo_subscription_event</li>
</ol>
</li>
<li>Periodic Snapshot Grain: corresponds to a predefined span of time.

<ol>
<li>Predictably dense.</li>
<li>Can be large even there is no activity.</li>
<li>E.g.: Account balance for an account at some time.</li>
</ol>
</li>
<li>Accumulating Snapshot Grain.

<ol>
<li>Fact entries are overwritten and udpated.</li>
<li>E.g.: Order processing</li>
</ol>
</li>
</ol>


<p>Surrogate Keys (integer key, assigned in sequence) are recommended for Fact tables.
In Vertica, CREATE SEQUENCE.</p>

<h4>Item 4.1: Interview for requirements</h4>

<p>Too smart interviewers make it harder to extract requirements from business:</p>

<ul>
<li>Long-winded questions</li>
<li>Even worse, some questions box the interviewee into a corner because of some bias. And the interviewees do not know how to get out.

<ul>
<li>Just ask and listen. Let them guide you step by step.</li>
</ul>
</li>
</ul>


<h4>Item 5.1-5.3: Compare normalized modeling (3NF) vs dimensional modeling (DM)</h4>

<p>Why dimensional modeling over normalized modeling?</p>

<ol>
<li>Normalized modeling is intended for transactional databases, making update and delete efficient. It’s not needed in BI/DW.</li>
<li>Normalized modeling for a complex business process will result in a very large ER diagram (similar to US cities-freeway maps). Business users cannot simply use that diagram to query what they need to know.

<ol>
<li>The result ER diagram is usually overwhelming and cannot be viewed in its entirety.</li>
<li>E.g.: How to drive from SJ to NY? Maybe going to Sacramento through 580, then to Salt Lake City, and then what? Joining tables in 3NF modeling is similar: you need to know which 10+ intermediate tables to join.</li>
<li>In the same analogy, it’s actually worse to join the tables since the tables are not static, they are moving cities.</li>
</ol>
</li>
</ol>


<p>Dimensional Modeling: top-down design process.</p>

<ul>
<li>Each fact table represents a business process.</li>
<li>Support two operations: browse and multi-table joins.</li>
<li>It is important to keep the dimension tables flat, without being normalized into snowflake structure.</li>
</ul>


<h3>Interview Questions</h3>

<p><a href="http://learndatamodeling.com/blog/data-modeling-interview-questions/">http://learndatamodeling.com/blog/data-modeling-interview-questions/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Database Question Bank]]></title>
    <link href="http://tdongsi.github.io/SqlTests/blog/2016/08/03/database-question-bank/"/>
    <updated>2016-08-03T01:41:54-07:00</updated>
    <id>http://tdongsi.github.io/SqlTests/blog/2016/08/03/database-question-bank</id>
    <content type="html"><![CDATA[<p>Questions about database in general. For data warehouse and dimensional modelling, check <a href="/blog/2016/09/15/tutorial-dimensional-modelling/">this</a>.</p>

<!--more-->


<h3>Relational Database topics</h3>

<p>Basics</p>

<ul>
<li>SELECTing columns from a table</li>
<li>Aggregates Part 1: COUNT, SUM, MAX/MIN</li>
<li>Aggregates Part 2: DISTINCT, GROUP BY, HAVING</li>
</ul>


<p>Intermediate</p>

<ul>
<li>JOINs, ANSI-89 and ANSI-92 syntax</li>
<li>UNION vs UNION ALL</li>
<li>NULL handling: COALESCE &amp; Native NULL handling</li>
<li>Subqueries: IN, EXISTS, and inline views</li>
<li>Subqueries: Correlated</li>
<li>WITH syntax: Subquery Factoring/CTE</li>
<li>Views</li>
</ul>


<p>Advanced Topics</p>

<ul>
<li>Functions, Stored Procedures, Packages</li>
<li>Pivoting data: CASE &amp; PIVOT syntax</li>
<li>Hierarchical Queries</li>
<li>Cursors: Implicit and Explicit</li>
<li>Triggers</li>
<li>Dynamic SQL</li>
<li>Materialized Views</li>
<li>Query Optimization: Indexes</li>
<li>Query Optimization: Explain Plans</li>
<li>Query Optimization: Profiling</li>
<li>Data Modelling: Normal Forms, 1 through 3</li>
<li>Data Modelling: Primary &amp; Foreign Keys</li>
<li>Data Modelling: Table Constraints</li>
<li>Data Modelling: Link/Corrollary Tables</li>
<li>Full Text Searching</li>
<li>XML</li>
<li>Isolation Levels</li>
<li>Entity Relationship Diagrams (ERDs), Logical and Physical</li>
<li>Transactions: COMMIT, ROLLBACK, Error Handling</li>
</ul>


<h4>References</h4>

<ul>
<li><a href="http://stackoverflow.com/questions/2119859/questions-every-good-database-sql-developer-should-be-able-to-answer">http://stackoverflow.com/questions/2119859/questions-every-good-database-sql-developer-should-be-able-to-answer</a></li>
<li><a href="http://www.careercup.com/page?pid=database-interview-questions">http://www.careercup.com/page?pid=database-interview-questions</a></li>
</ul>


<h3>Questions</h3>

<p>(1) Given these two databases:</p>

<pre><code class="plain Given databases">id name id name 
-- ---- -- ---- 
1 Pirate 1 Rutabaga 
2 Monkey 2 Pirate 
3 Ninja 3 Darth Vader 
4 Spaghetti 4 Ninja
</code></pre>

<p>Explain the following JOINs:</p>

<ol>
<li>INNER JOIN</li>
<li>LEFT and RIGHT OUTER JOIN</li>
<li>FULL JOIN</li>
<li>CROSS JOIN</li>
</ol>


<p>B set:</p>

<ol>
<li>What is normalization and why is it important?</li>
<li>What are some situations where you would de-normalize data?</li>
<li>What is a transaction and why is it important?</li>
<li>What is referential integrity and why is it important?</li>
<li>What steps would to take to investigate reports of slow database performance?</li>
<li>What is an index and how does it help your database?</li>
<li>If someone were to make the claim that: &ldquo;every SELECT always include DISTINCT&rdquo;; how would you comment on the claim?
OLTP and OLAP points of view?</li>
</ol>


<h3>Answer keys</h3>

<h4>Section A</h4>

<p>(1) <a href="http://www.codinghorror.com/blog/2007/10/a-visual-explanation-of-sql-joins.html">http://www.codinghorror.com/blog/2007/10/a-visual-explanation-of-sql-joins.html</a></p>

<h4>Section B</h4>

<p>(1) Normalizing: remove redundancy -> remove update and delete anomaly -> more efficient data storage and consistent data.</p>

<p>Summary from Introduction to Databases
To reduce redundancy. From redundancy, it will lead to update and delete anomaly.
E.g.: dim_company: region/country info will be repeated -> redundancy.
E.g.: North Korea and South Korea merged into Korea -> delete those regions will delete companies -> delete anomaly.</p>

<p>Popular normal forms:</p>

<p>BCNF: For each functional dependency A-> B, A is key.
Functional dependency: A -> B: same A leads to same B. E.g.: ID -> name.</p>

<p>4NF: Functional dependency + Multivalued dependency.
Multivalued dependency: A ->> B, C: each A lead to all combo (B x C). E.g.: ID -> region x language
4NF: For each multivalued dependency A ->> B, C, A is key. I.e.: (A, B, C) is decomposed to (A, B) and (A, C).</p>

<p>(2) When there is no data update or deletion. For example: data warehouse situations.
Analytical processing: joining multiple tables is not efficient. The SQL queries are hard to write.</p>

<p>(3)Why is transaction is important:</p>

<ul>
<li>Concurrency: Ensure consistent data read/write while providing concurrent data access.</li>
<li>Failure-tolerance: Resilience to system failures.</li>
</ul>


<p>A transaction is a sequence of SQL statements treated as a unit. The effect of a transaction is either full or none at all.
Transactions appear to run in isolation.</p>

<p>ACID: atomic, consistency, isolation, durability</p>

<p>(4) You have a foreign key, reference to another table.
When that key is deleted from the other table, referential integrity is compromised.</p>

<p>(5) Check current state: hang processes, long running queries.
Optimize SQL queries.
Indexes.</p>

<p>(6) What is it: persistent data structure, stored in database.
Purpose: improve data lookup performance.
Instead of scanning a whole relational table for a record, using the index, the location of a record can be returned almost immediately.
Implementation: Balanced trees (B tree, B+ tree), Hash Map (for equality condition only)</p>

<p>A database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure.
An index is a copy of select columns of data from a table that can be searched very efficiently that also includes a low-level disk block address or direct link to the complete row of data it was copied from.</p>

<p>(7) OLTP: Suppose your query is correct, and does not return any duplicates, then including DISTINCT simply forces the RDBMS to check your result (zero benefit, and a lot of additional processing).
Suppose your query is incorrect, and does return duplicates, then including DISTINCT simply hides the problem (again with additional processing).
It would be better to spot the problem and fix your query.
It&rsquo;ll run faster that way.</p>
]]></content>
  </entry>
  
</feed>
